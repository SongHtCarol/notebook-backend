# C++ 相关

- [C++ 相关](#c-相关)
  - [指针](#指针)
    - [指针和引用](#指针和引用)
    - [迭代器和指针](#迭代器和指针)
      - [一、定义](#一定义)
        - [1. 指针](#1-指针)
        - [2. 迭代器](#2-迭代器)
      - [二、核心区别](#二核心区别)
      - [三、详细对比](#三详细对比)
        - [1. 访问方式](#1-访问方式)
        - [2. 遍历操作](#2-遍历操作)
        - [3. 安全性](#3-安全性)
        - [4. 泛型编程](#4-泛型编程)
      - [四、迭代器的分类](#四迭代器的分类)
      - [五、总结](#五总结)
  - [栈指针 和 指针](#栈指针-和-指针)
    - [**一、定义**](#一定义-1)
      - [1. **指针**](#1-指针-1)
      - [2. **栈指针**](#2-栈指针)
    - [**二、核心区别**](#二核心区别-1)
    - [**三、详细对比**](#三详细对比-1)
      - [1. **作用**](#1-作用)
      - [2. **存储位置**](#2-存储位置)
      - [3. **使用场景**](#3-使用场景)
      - [4. **生命周期**](#4-生命周期)
      - [5. **抽象层次**](#5-抽象层次)
    - [**四、示例**](#四示例)
      - [1. **指针示例**](#1-指针示例)
      - [2. **栈指针示例**](#2-栈指针示例)
    - [**五、总结**](#五总结-1)
  - [堆和栈](#堆和栈)
    - [一、堆和栈的定义](#一堆和栈的定义)
      - [1. **栈（Stack）**](#1-栈stack)
      - [2. **堆（Heap）**](#2-堆heap)
    - [二、核心区别](#二核心区别-2)
    - [三、详细对比](#三详细对比-2)
      - [1. **内存管理**](#1-内存管理)
      - [2. **生命周期**](#2-生命周期)
      - [3. **分配速度**](#3-分配速度)
      - [4. **访问方式**](#4-访问方式)
      - [5. **碎片问题**](#5-碎片问题)
      - [6. **适用场景**](#6-适用场景)
    - [四、示例对比](#四示例对比)
      - [1. **栈示例**](#1-栈示例)
      - [2. **堆示例**](#2-堆示例)
    - [五、常见问题](#五常见问题)
      - [1. **栈溢出（Stack Overflow）**](#1-栈溢出stack-overflow)
      - [2. **内存泄漏（Memory Leak）**](#2-内存泄漏memory-leak)
      - [3. **内存碎片（Memory Fragmentation）**](#3-内存碎片memory-fragmentation)
    - [六、总结](#六总结)
  - [为什么栈向下增长](#为什么栈向下增长)
    - [1. **内存布局**](#1-内存布局)
    - [2. **栈向下增长的原因**](#2-栈向下增长的原因)
      - [（1）**历史原因**](#1历史原因)
      - [（2）**与堆的互补**](#2与堆的互补)
      - [（3）**简化内存管理**](#3简化内存管理)
      - [（4）**硬件支持**](#4硬件支持)
    - [3. **栈向下增长的实现**](#3-栈向下增长的实现)
      - [示例：](#示例)
    - [4. **栈向下增长的优点**](#4-栈向下增长的优点)
      - [（1）**高效的内存利用**](#1高效的内存利用)
      - [（2）**简单的指针管理**](#2简单的指针管理)
      - [（3）**硬件优化**](#3硬件优化)
    - [5. **栈向下增长的缺点**](#5-栈向下增长的缺点)
    - [6. **总结**](#6-总结)
  - [`int* ptr;`  分配在堆上还是栈上](#int-ptr--分配在堆上还是栈上)
    - [**1. `ptr` 变量本身的存储位置**](#1-ptr-变量本身的存储位置)
    - [**2. `ptr` 指向的内存的存储位置**](#2-ptr-指向的内存的存储位置)
    - [**关键总结**](#关键总结)
    - [**示例代码**](#示例代码)
      - [（1）指针变量在栈上，指向栈内存：](#1指针变量在栈上指向栈内存)
      - [（2）指针变量在栈上，指向堆内存：](#2指针变量在栈上指向堆内存)
      - [（3）全局指针变量：](#3全局指针变量)
    - [**常见误区**](#常见误区)
    - [**结论**](#结论)
  - [new vs malloc](#new-vs-malloc)
    - [**1. 基本概念**](#1-基本概念)
    - [**2. 内存分配与初始化**](#2-内存分配与初始化)
    - [**3. 内存释放**](#3-内存释放)
    - [**4. 类型安全**](#4-类型安全)
    - [**5. 异常处理**](#5-异常处理)
    - [**6. 适用场景**](#6-适用场景-1)
    - [**7. 性能与灵活性**](#7-性能与灵活性)
    - [**代码示例对比**](#代码示例对比)
      - [使用 `new` 和 `delete`：](#使用-new-和-delete)
      - [使用 `malloc` 和 `free`：](#使用-malloc-和-free)
    - [**总结**](#总结)
  - [动态内存](#动态内存)
    - [**一、动态内存的核心概念**](#一动态内存的核心概念)
    - [**二、动态内存的操作方法**](#二动态内存的操作方法)
      - [1. **C 语言中的动态内存**](#1-c-语言中的动态内存)
      - [2. **C++ 中的动态内存**](#2-c-中的动态内存)
      - [3. **智能指针（C++11+）**](#3-智能指针c11)
    - [**三、动态内存的优缺点**](#三动态内存的优缺点)
    - [**四、动态内存的常见问题**](#四动态内存的常见问题)
    - [**五、动态内存的应用场景**](#五动态内存的应用场景)
    - [**六、最佳实践**](#六最佳实践)
    - [**总结**](#总结-1)
  - [mutex vs shared\_mutex](#mutex-vs-shared_mutex)
    - [**一、基本概念**](#一基本概念)
      - [1. **`mutex`（互斥锁）**](#1-mutex互斥锁)
      - [2. **`shared_mutex`（共享互斥锁）**](#2-shared_mutex共享互斥锁)
    - [**二、核心区别**](#二核心区别-3)
    - [**三、详细对比**](#三详细对比-3)
      - [1. **锁模式**](#1-锁模式)
      - [2. **适用场景**](#2-适用场景)
      - [3. **性能**](#3-性能)
      - [4. **C++ 标准**](#4-c-标准)
    - [**四、示例代码**](#四示例代码)
      - [1. **`mutex` 示例**](#1-mutex-示例)
      - [2. **`shared_mutex` 示例**](#2-shared_mutex-示例)
    - [**五、总结**](#五总结-2)
  - [vector](#vector)
    - [1. **头文件与声明**](#1-头文件与声明)
    - [2. **核心操作**](#2-核心操作)
    - [3. **遍历方式**](#3-遍历方式)
    - [4. **性能特点**](#4-性能特点)
    - [5. **适用场景**](#5-适用场景)
    - [6. **示例代码**](#6-示例代码)
    - [7. **最佳实践**](#7-最佳实践)
    - [8. **与其他容器的对比**](#8-与其他容器的对比)
  - [C++ push\_back 左值和右值的区别](#c-push_back-左值和右值的区别)
    - [1. 左值 (Lvalue)](#1-左值-lvalue)
    - [2. 右值 (Rvalue)](#2-右值-rvalue)
    - [3. 移动语义](#3-移动语义)
    - [总结](#总结-2)
  - [移动语义](#移动语义)
    - [1. 核心思想](#1-核心思想)
    - [2. 右值和右值引用](#2-右值和右值引用)
    - [3. 移动构造函数和移动赋值运算符](#3-移动构造函数和移动赋值运算符)
      - [示例代码](#示例代码-1)
    - [4. `std::move` 的作用](#4-stdmove-的作用)
      - [示例](#示例-1)
    - [5. 移动语义的优势](#5-移动语义的优势)
    - [6. 移动语义的应用场景](#6-移动语义的应用场景)
    - [7. 注意事项](#7-注意事项)
    - [总结](#总结-3)
  - [什么情况下需要显示调用析构函数](#什么情况下需要显示调用析构函数)
    - [1. **手动管理对象的生命周期**](#1-手动管理对象的生命周期)
      - [示例](#示例-2)
    - [2. **自定义内存池或对象池**](#2-自定义内存池或对象池)
      - [示例](#示例-3)
    - [3. **处理未初始化内存**](#3-处理未初始化内存)
      - [示例](#示例-4)
    - [4. **优化性能**](#4-优化性能)
    - [5. **处理低级数据结构**](#5-处理低级数据结构)
      - [示例](#示例-5)
    - [6. **调试和测试**](#6-调试和测试)
    - [注意事项](#注意事项)
    - [总结](#总结-4)
  - [只调用析构函数，但没有释放内存会发生什么](#只调用析构函数但没有释放内存会发生什么)
    - [**1. 资源泄漏**](#1-资源泄漏)
      - [示例](#示例-6)
    - [**2. 内存泄漏**](#2-内存泄漏)
    - [**3. 重复析构（双重释放）**](#3-重复析构双重释放)
      - [示例](#示例-7)
    - [**4. 对象状态失效**](#4-对象状态失效)
    - [**何时可以安全地仅调用析构函数？**](#何时可以安全地仅调用析构函数)
      - [**使用 Placement New**](#使用-placement-new)
    - [**总结**](#总结-5)
    - [**最佳实践**](#最佳实践)
  - [析构函数的使用](#析构函数的使用)
    - [**一、析构函数销毁的典型资源**](#一析构函数销毁的典型资源)
      - [1. **动态分配的内存**](#1-动态分配的内存)
      - [2. **文件句柄（File Handles）**](#2-文件句柄file-handles)
      - [3. **数据库连接、网络连接**](#3-数据库连接网络连接)
      - [4. **互斥锁（Mutex Locks）**](#4-互斥锁mutex-locks)
      - [5. **其他对象的成员**](#5-其他对象的成员)
      - [6. **基类资源**](#6-基类资源)
    - [**二、析构函数 *不* 销毁的资源**](#二析构函数-不-销毁的资源)
      - [1. **栈内存（局部变量）**](#1-栈内存局部变量)
      - [2. **静态变量（Static Variables）**](#2-静态变量static-variables)
      - [3. **智能指针管理的资源**](#3-智能指针管理的资源)
    - [**三、析构函数的调用规则**](#三析构函数的调用规则)
    - [**四、最佳实践**](#四最佳实践)
    - [**五、总结**](#五总结-3)
  - [默认析构函数](#默认析构函数)
    - [**一、默认析构函数的行为**](#一默认析构函数的行为)
      - [1. **自动调用成员对象和基类的析构函数**](#1-自动调用成员对象和基类的析构函数)
      - [2. **不处理动态资源**](#2-不处理动态资源)
    - [**二、何时可以使用默认析构函数？**](#二何时可以使用默认析构函数)
      - [1. **类的成员均为自动管理资源的类型**](#1-类的成员均为自动管理资源的类型)
      - [2. **类没有动态分配的资源**](#2-类没有动态分配的资源)
      - [3. **基类析构函数为虚函数**](#3-基类析构函数为虚函数)
    - [**三、何时必须自定义析构函数？**](#三何时必须自定义析构函数)
      - [1. **手动管理动态资源**](#1-手动管理动态资源)
      - [2. **复杂资源管理**](#2-复杂资源管理)
      - [3. **处理非 RAII 类型的资源**](#3-处理非-raii-类型的资源)
    - [**四、默认析构函数的总结**](#四默认析构函数的总结)
    - [**五、最佳实践**](#五最佳实践)
  - [构造函数都做了什么？ 一个对象在内存中怎么分布？](#构造函数都做了什么-一个对象在内存中怎么分布)
    - [**一、构造函数的作用**](#一构造函数的作用)
      - [1. **初始化成员变量**](#1-初始化成员变量)
      - [2. **分配动态资源**](#2-分配动态资源)
      - [3. **执行初始化逻辑**](#3-执行初始化逻辑)
      - [4. **调用基类和成员对象的构造函数**](#4-调用基类和成员对象的构造函数)
      - [5. **委托构造函数（C++11+）**](#5-委托构造函数c11)
    - [**二、对象在内存中的分布**](#二对象在内存中的分布)
      - [1. **普通类对象**](#1-普通类对象)
      - [2. **继承类对象**](#2-继承类对象)
      - [3. **虚函数表（vtable）**](#3-虚函数表vtable)
      - [4. **多继承对象**](#4-多继承对象)
    - [**三、内存对齐**](#三内存对齐)
    - [**四、总结**](#四总结)
  - [类里的成员变量都分配在堆上吗](#类里的成员变量都分配在堆上吗)
    - [**一、成员变量的内存分配位置**](#一成员变量的内存分配位置)
      - [1. **对象创建方式决定内存位置**](#1-对象创建方式决定内存位置)
      - [2. **成员变量类型决定内存位置**](#2-成员变量类型决定内存位置)
    - [**二、成员变量内存分配的示例**](#二成员变量内存分配的示例)
      - [1. **栈上对象**](#1-栈上对象)
      - [2. **堆上对象**](#2-堆上对象)
      - [3. **指针成员变量**](#3-指针成员变量)
      - [4. **动态数组或容器**](#4-动态数组或容器)
    - [**三、总结**](#三总结)
  - [virtual 关键字的作用](#virtual-关键字的作用)
    - [**1. 实现多态**](#1-实现多态)
      - [**核心作用**：](#核心作用)
      - [**示例**：](#示例-8)
    - [**2. 虚析构函数**](#2-虚析构函数)
      - [**必要性**：](#必要性)
      - [**示例**：](#示例-9)
    - [**3. 纯虚函数与抽象类**](#3-纯虚函数与抽象类)
      - [**纯虚函数**：](#纯虚函数)
      - [**示例**：](#示例-10)
    - [**4. 虚函数表（vtable）**](#4-虚函数表vtable)
      - [**底层机制**：](#底层机制)
      - [**内存开销**：](#内存开销)
    - [**5. 使用场景**](#5-使用场景)
    - [**6. 注意事项**](#6-注意事项)
    - [**总结**](#总结-6)
  - [虚函数表](#虚函数表)
    - [**1. 虚函数表的核心作用**](#1-虚函数表的核心作用)
    - [**2. 虚函数表的结构**](#2-虚函数表的结构)
      - [**示例：单继承的虚函数表**](#示例单继承的虚函数表)
    - [**3. 虚函数表的底层工作原理**](#3-虚函数表的底层工作原理)
      - [**(1) 对象内存布局**](#1-对象内存布局)
      - [**(2) 虚函数调用过程**](#2-虚函数调用过程)
    - [**4. 虚函数表在多继承中的处理**](#4-虚函数表在多继承中的处理)
      - [**示例：多继承**](#示例多继承)
    - [**5. 虚函数表的开销**](#5-虚函数表的开销)
    - [**6. 虚函数表的实现差异**](#6-虚函数表的实现差异)
    - [**7. 如何观察虚函数表？**](#7-如何观察虚函数表)
      - [**(1) 通过调试器**](#1-通过调试器)
      - [**(2) 手动解析内存（示例）**](#2-手动解析内存示例)
    - [**8. 虚函数表的实际应用**](#8-虚函数表的实际应用)
    - [**总结**](#总结-7)
  - [什么场景下需要禁止派生类重写基类虚函数？](#什么场景下需要禁止派生类重写基类虚函数)
    - [**一、禁止重写虚函数的核心原因**](#一禁止重写虚函数的核心原因)
      - [1. **维护关键行为的一致性**](#1-维护关键行为的一致性)
      - [2. **防止破坏基类不变性（Invariants）**](#2-防止破坏基类不变性invariants)
      - [3. **优化性能**](#3-优化性能)
      - [4. **强制接口与实现的分离**](#4-强制接口与实现的分离)
    - [**二、如何禁止虚函数重写？**](#二如何禁止虚函数重写)
      - [1. **使用 `final` 关键字（C++11+）**](#1-使用-final-关键字c11)
      - [2. **非虚函数设计**](#2-非虚函数设计)
    - [**三、禁止重写的适用场景**](#三禁止重写的适用场景)
    - [**四、注意事项**](#四注意事项)
    - [**五、总结**](#五总结-4)
  - [基类里的成员函数一定是虚函数吗](#基类里的成员函数一定是虚函数吗)
    - [**1. 基类函数非虚的情况**](#1-基类函数非虚的情况)
      - [**示例**：](#示例-11)
    - [**2. 基类函数为虚的情况**](#2-基类函数为虚的情况)
      - [**示例**：](#示例-12)
    - [**3. 必须使用虚函数的情况**](#3-必须使用虚函数的情况)
      - [**(1) 实现多态**](#1-实现多态-1)
      - [**(2) 虚析构函数**](#2-虚析构函数-1)
    - [**4. 基类函数是否应为虚函数？**](#4-基类函数是否应为虚函数)
    - [**5. 虚函数的开销**](#5-虚函数的开销)
    - [**总结**](#总结-8)
  - [vector vs deque](#vector-vs-deque)
    - [**一、`deque`的核心特性**](#一deque的核心特性)
    - [**二、`deque`的内部实现**](#二deque的内部实现)
      - [1. **分段连续存储**](#1-分段连续存储)
      - [2. **迭代器设计**](#2-迭代器设计)
      - [3. **扩容机制**](#3-扩容机制)
    - [**三、`deque`的操作与复杂度**](#三deque的操作与复杂度)
    - [**四、`deque`的代码示例**](#四deque的代码示例)
      - [1. **基本操作**](#1-基本操作)
      - [2. **与`vector`的性能对比**](#2-与vector的性能对比)
    - [**五、`deque`的适用场景**](#五deque的适用场景)
    - [**六、`deque`的局限性**](#六deque的局限性)
    - [**七、与其他容器的对比**](#七与其他容器的对比)
    - [**八、总结**](#八总结)
  - [vector vs array](#vector-vs-array)
    - [**一、基本概念**](#一基本概念-1)
      - [1. **`std::vector`**](#1-stdvector)
      - [2. **`std::array`**](#2-stdarray)
    - [**二、核心区别**](#二核心区别-4)
    - [**三、详细对比**](#三详细对比-4)
      - [1. **大小**](#1-大小)
      - [2. **内存管理**](#2-内存管理)
      - [3. **性能**](#3-性能-1)
      - [4. **适用场景**](#4-适用场景)
      - [5. **C++ 标准**](#5-c-标准)
    - [**四、示例代码**](#四示例代码-1)
      - [1. **`std::vector` 示例**](#1-stdvector-示例)
      - [2. **`std::array` 示例**](#2-stdarray-示例)
    - [**五、总结**](#五总结-5)
  - [vector\\list\\deque\\queue](#vectorlistdequequeue)
    - [**1. 数据结构与内存布局**](#1-数据结构与内存布局)
    - [**2. 时间复杂度对比**](#2-时间复杂度对比)
    - [**3. 核心特性与适用场景**](#3-核心特性与适用场景)
      - [**`vector`**](#vector-1)
      - [**`list`**](#list)
      - [**`deque`**](#deque)
      - [**`queue`**](#queue)
    - [**4. 迭代器与内存管理**](#4-迭代器与内存管理)
    - [**5. 代码示例**](#5-代码示例)
      - [**`vector`：动态数组**](#vector动态数组)
      - [**`list`：双向链表**](#list双向链表)
      - [**`deque`：双端队列**](#deque双端队列)
      - [**`queue`：队列适配器**](#queue队列适配器)
    - [**6. 总结**](#6-总结-1)
  - [list](#list-1)
    - [**1. 基本特性**](#1-基本特性)
    - [**2. 核心操作**](#2-核心操作-1)
      - [**(1) 构造函数**](#1-构造函数)
      - [**(2) 插入元素**](#2-插入元素)
      - [**(3) 删除元素**](#3-删除元素)
      - [**(4) 访问元素**](#4-访问元素)
    - [**3. 迭代器稳定性**](#3-迭代器稳定性)
    - [**4. 算法与成员函数**](#4-算法与成员函数)
      - [**(1) 排序**](#1-排序)
      - [**(2) 合并**](#2-合并)
      - [**(3) 去重**](#3-去重)
      - [**(4) 拼接**](#4-拼接)
    - [**5. 优缺点分析**](#5-优缺点分析)
      - [**优点**：](#优点)
      - [**缺点**：](#缺点)
    - [**6. 适用场景**](#6-适用场景-2)
    - [**7. 示例代码**](#7-示例代码)
      - [**实现 LRU 缓存**](#实现-lru-缓存)
    - [**总结**](#总结-9)
  - [string](#string)
    - [**一、基本特性**](#一基本特性)
    - [**二、常用操作**](#二常用操作)
      - [1. **构造和初始化**](#1-构造和初始化)
      - [2. **访问元素**](#2-访问元素)
      - [3. **修改字符串**](#3-修改字符串)
      - [4. **查找和替换**](#4-查找和替换)
      - [5. **大小和容量**](#5-大小和容量)
      - [6. **比较字符串**](#6-比较字符串)
      - [7. **转换**](#7-转换)
    - [**三、示例代码**](#三示例代码)
    - [**四、性能优化**](#四性能优化)
    - [**五、总结**](#五总结-6)
  - [sizeof](#sizeof)
    - [1. `sizeof` 的基本用法](#1-sizeof-的基本用法)
      - [示例：](#示例-13)
      - [输出：](#输出)
    - [2. `sizeof` 与 C++11 新特性](#2-sizeof-与-c11-新特性)
      - [（1）`sizeof` 与 `decltype`](#1sizeof-与-decltype)
        - [示例：](#示例-14)
        - [输出：](#输出-1)
      - [（2）`sizeof` 与 `alignof`](#2sizeof-与-alignof)
        - [示例：](#示例-15)
        - [输出：](#输出-2)
    - [3. `sizeof` 的特殊用法](#3-sizeof-的特殊用法)
      - [（1）计算数组的大小](#1计算数组的大小)
        - [示例：](#示例-16)
        - [输出：](#输出-3)
      - [（2）计算结构体的大小](#2计算结构体的大小)
        - [示例：](#示例-17)
        - [输出：](#输出-4)
    - [4. `sizeof` 的注意事项](#4-sizeof-的注意事项)
    - [5. 总结](#5-总结)
  - [sizeof（void）](#sizeofvoid)
    - [1. 为什么 `sizeof(void)` 不合法？](#1-为什么-sizeofvoid-不合法)
    - [2. 示例代码](#2-示例代码)
      - [编译器错误：](#编译器错误)
    - [3. `sizeof(void*)` 是合法的](#3-sizeofvoid-是合法的)
      - [示例：](#示例-18)
      - [输出：](#输出-5)
    - [4. 总结](#4-总结)
  - [前置自增](#前置自增)
    - [1. 语法](#1-语法)
    - [2. 行为](#2-行为)
      - [示例：](#示例-19)
    - [3. 与后置自增的区别](#3-与后置自增的区别)
      - [示例对比：](#示例对比)
    - [4. 性能分析](#4-性能分析)
    - [5. 适用场景](#5-适用场景-1)
      - [示例：循环中使用前置自增](#示例循环中使用前置自增)
    - [6. 自定义类型中的前置自增](#6-自定义类型中的前置自增)
      - [示例：](#示例-20)
    - [7. 总结](#7-总结)
  - [单例模式](#单例模式)
    - [**一、经典实现（非线程安全）**](#一经典实现非线程安全)
      - [1. **实现代码**](#1-实现代码)
      - [2. **使用示例**](#2-使用示例)
      - [3. **特点**](#3-特点)
    - [**二、线程安全实现（C++11）**](#二线程安全实现c11)
      - [1. **实现代码**](#1-实现代码-1)
      - [2. **使用示例**](#2-使用示例-1)
      - [3. **特点**](#3-特点-1)
    - [**三、双重检查锁定（Double-Checked Locking）**](#三双重检查锁定double-checked-locking)
      - [1. **实现代码**](#1-实现代码-2)
      - [2. **使用示例**](#2-使用示例-2)
      - [3. **特点**](#3-特点-2)
    - [**四、Meyer's Singleton（推荐）**](#四meyers-singleton推荐)
      - [1. **实现代码**](#1-实现代码-3)
      - [2. **使用示例**](#2-使用示例-3)
      - [3. **特点**](#3-特点-3)
    - [**五、总结**](#五总结-7)
  - [LRU](#lru)
    - [**设计思路**](#设计思路)
    - [**代码实现**](#代码实现)
    - [**代码说明**](#代码说明)
    - [**测试与优化**](#测试与优化)
    - [**总结**](#总结-10)
  - [检测内存泄漏的工具](#检测内存泄漏的工具)
    - [一、工具分类](#一工具分类)
      - [1. **静态分析工具**](#1-静态分析工具)
      - [2. **动态分析工具**](#2-动态分析工具)
    - [二、常用工具](#二常用工具)
      - [1. **Valgrind**](#1-valgrind)
      - [2. **AddressSanitizer (ASan)**](#2-addresssanitizer-asan)
      - [3. **Dr. Memory**](#3-dr-memory)
      - [4. **Visual Studio 内存分析工具**](#4-visual-studio-内存分析工具)
      - [5. **LeakSanitizer (LSan)**](#5-leaksanitizer-lsan)
      - [6. **Electric Fence**](#6-electric-fence)
      - [7. **Cppcheck**](#7-cppcheck)
    - [三、选择工具的建议](#三选择工具的建议)
    - [四、预防内存泄漏的最佳实践](#四预防内存泄漏的最佳实践)
    - [五、总结](#五总结-8)
  - [什么是泛型编程](#什么是泛型编程)
    - [**为什么需要泛型编程？**](#为什么需要泛型编程)
    - [**泛型编程的实现方式**](#泛型编程的实现方式)
      - [1. **C++ 的模板（Templates）**](#1-c-的模板templates)
      - [2. **Java 的泛型（Generics）**](#2-java-的泛型generics)
      - [3. **Go 的泛型（1.18+ 版本）**](#3-go-的泛型118-版本)
      - [4. **Rust 的泛型**](#4-rust-的泛型)
    - [**泛型编程的优势**](#泛型编程的优势)
    - [**泛型编程的典型应用场景**](#泛型编程的典型应用场景)
    - [**泛型编程的挑战**](#泛型编程的挑战)
    - [**总结**](#总结-11)
  - [C++ stl标准库](#c-stl标准库)
    - [**一、STL 的六大核心组件**](#一stl-的六大核心组件)
    - [**二、容器（Containers）**](#二容器containers)
      - [1. **顺序容器**](#1-顺序容器)
      - [2. **关联容器**](#2-关联容器)
      - [3. **容器适配器**](#3-容器适配器)
    - [**三、算法（Algorithms）**](#三算法algorithms)
    - [**四、迭代器（Iterators）**](#四迭代器iterators)
    - [**五、函数对象（Function Objects）**](#五函数对象function-objects)
    - [**六、适配器（Adapters）**](#六适配器adapters)
    - [**七、分配器（Allocators）**](#七分配器allocators)
    - [**八、STL 的优势**](#八stl-的优势)
    - [**九、STL 的局限性**](#九stl-的局限性)

---
## 指针
### 指针和引用

- 指针是一个变量，需要申请内存空间，保存所指向变量的地址；
- 引用是变量的别名，不需要额外申请内存空间，与原变量共享内存地址。
- 引用初始化后，就不能改变，永远和原来的变量绑定。
    <img src='/c++11/img/pointer.jpg'>
- 获取指针指向变量的值需要对指针解引用(回内存地址中对应的对象)。 即*
- 引用没有const，指针有const，const指针不可变。
    <img src='/c++11/img/error.jpg'>
    <img src='/c++11/img/pointer1.jpg'>
- 可以声明只读的引用 `const int& m = i`, 只读的引用不能修改原变量的值
    <img src='/c++11/img/error1.jpg'>
- 只读的指针可以改变指向的变量，但是不能修改指向变量的值。
    <img src='/c++11/img/error2.jpg'>

---
### 迭代器和指针
**迭代器（Iterator）** 和 **指针（Pointer）** 都是用于访问和遍历数据结构的工具，但它们在设计、功能和使用场景上有显著区别。以下是它们的详细对比：


#### 一、定义
##### 1. 指针
- 指针是 C/C++ 中的一种变量，存储内存地址。
- 可以直接访问内存中的数据，支持算术运算（如 `++`、`--`）。

##### 2. 迭代器
- 迭代器是 C++ 标准库中的一种抽象概念，用于遍历容器（如 `std::vector`、`std::list`）。
- 提供统一的接口访问容器元素，隐藏底层实现细节。


#### 二、核心区别
| **特性**               | **指针**                              | **迭代器**                          |
|------------------------|----------------------------------------|-------------------------------------|
| **语言支持**           | C/C++ 原生支持                         | C++ 标准库支持                      |
| **适用范围**           | 数组、动态内存                         | 标准库容器（如 `vector`、`list`）   |
| **抽象层次**           | 低级别，直接操作内存                   | 高级别，封装底层实现                |
| **安全性**             | 容易出错（如空指针、越界访问）         | 更安全（如边界检查）                |
| **功能扩展**           | 仅支持基本操作（如 `++`、`--`）        | 支持丰富操作（如 `begin()`、`end()`）|
| **泛型编程**           | 不支持                                 | 支持（如 STL 算法）                 |


#### 三、详细对比
##### 1. 访问方式
- **指针**：
  - 直接访问内存地址，适用于数组和动态内存。
  - 示例：
    ```cpp
    int arr[] = {1, 2, 3};
    int* p = arr;
    std::cout << *p << std::endl; // 输出 1
    ```

- **迭代器**：
  - 通过容器提供的接口访问元素，适用于标准库容器。
  - 示例：
    ```cpp
    std::vector<int> vec = {1, 2, 3};
    auto it = vec.begin();
    std::cout << *it << std::endl; // 输出 1
    ```

##### 2. 遍历操作
- **指针**：
  - 使用指针算术运算（如 `++`、`--`）遍历数组。
  - 示例：
    ```cpp
    int arr[] = {1, 2, 3};
    for (int* p = arr; p != arr + 3; ++p) {
        std::cout << *p << std::endl;
    }
    ```

- **迭代器**：
  - 使用迭代器的 `++`、`--` 操作遍历容器。
  - 示例：
    ```cpp
    std::vector<int> vec = {1, 2, 3};
    for (auto it = vec.begin(); it != vec.end(); ++it) {
        std::cout << *it << std::endl;
    }
    ```

##### 3. 安全性
- **指针**：
  - 容易引发空指针、野指针、越界访问等问题。
  - 示例：
    ```cpp
    int* p = nullptr;
    std::cout << *p << std::endl; // 运行时错误
    ```

- **迭代器**：
  - 提供边界检查，更安全。
  - 示例：
    ```cpp
    std::vector<int> vec = {1, 2, 3};
    auto it = vec.end();
    std::cout << *it << std::endl; // 未定义行为，但部分实现会抛出异常
    ```

##### 4. 泛型编程
- **指针**：
  - 不支持泛型编程，无法直接用于标准库算法。
- **迭代器**：
  - 支持泛型编程，可与 STL 算法（如 `std::sort`、`std::find`）结合使用。
  - 示例：
    ```cpp
    std::vector<int> vec = {3, 1, 2};
    std::sort(vec.begin(), vec.end());
    ```


#### 四、迭代器的分类
C++ 标准库中的迭代器分为以下几类：
1. **输入迭代器（Input Iterator）**：
   - 只读，单向遍历（如 `std::istream_iterator`）。
2. **输出迭代器（Output Iterator）**：
   - 只写，单向遍历（如 `std::ostream_iterator`）。
3. **前向迭代器（Forward Iterator）**：
   - 可读写，单向遍历（如 `std::forward_list` 的迭代器）。
4. **双向迭代器（Bidirectional Iterator）**：
   - 可读写，双向遍历（如 `std::list` 的迭代器）。
5. **随机访问迭代器（Random Access Iterator）**：
   - 可读写，支持随机访问（如 `std::vector` 的迭代器）。


#### 五、总结
- **指针**：
  - 低级别，直接操作内存，适合数组和动态内存。
  - 容易出错，不支持泛型编程。
- **迭代器**：
  - 高级别，封装底层实现，适合标准库容器。
  - 更安全，支持泛型编程和丰富操作。

在实际开发中，优先使用迭代器，除非需要直接操作内存或与 C 代码交互。

--- 

## 栈指针 和 指针
**栈指针（Stack Pointer）** 和 **指针（Pointer）** 是两种不同的概念，尽管它们都涉及内存地址，但在作用和使用场景上有显著区别。以下是它们的详细对比：


### **一、定义**
#### 1. **指针**
- 指针是 C/C++ 中的一种变量，存储内存地址。
- 可以指向任意类型的数据（如 `int`、`char`、结构体等）。
- 示例：
  ```cpp
  int a = 10;
  int* p = &a; // p 是指向 a 的指针
  ```

#### 2. **栈指针**
- 栈指针是 CPU 寄存器（如 `ESP` 或 `RSP`）中的一种特殊指针，用于管理函数调用栈。
- 指向当前栈顶的内存地址。
- 示例：
  - 在汇编语言中，`ESP` 是栈指针寄存器。


### **二、核心区别**
| **特性**               | **指针**                              | **栈指针**                          |
|------------------------|----------------------------------------|-------------------------------------|
| **作用**               | 存储任意内存地址                       | 管理函数调用栈                      |
| **存储位置**           | 内存中的变量                           | CPU 寄存器（如 `ESP`、`RSP`）       |
| **使用场景**           | 访问动态内存、数组、结构体等           | 函数调用、局部变量分配              |
| **生命周期**           | 由程序员控制                           | 由编译器自动管理                    |
| **抽象层次**           | 高级语言特性                           | 低级硬件特性                        |


### **三、详细对比**
#### 1. **作用**
- **指针**：
  - 用于访问和操作内存中的数据。
  - 可以指向堆、栈、全局变量等任意内存区域。
  - 示例：
    ```cpp
    int* p = new int(10); // 指向堆内存
    ```

- **栈指针**：
  - 用于管理函数调用栈。
  - 指向当前栈顶，用于分配和释放局部变量。
  - 示例：
    - 函数调用时，栈指针下移，为局部变量分配空间。
    - 函数返回时，栈指针上移，释放局部变量。

#### 2. **存储位置**
- **指针**：
  - 存储在内存中，是一个普通变量。
  - 示例：
    ```cpp
    int* p; // p 是内存中的一个变量
    ```

- **栈指针**：
  - 存储在 CPU 寄存器中（如 `ESP` 或 `RSP`）。
  - 示例：
    - 在 x86 架构中，`ESP` 是栈指针寄存器。

#### 3. **使用场景**
- **指针**：
  - 动态内存分配（如 `new`、`malloc`）。
  - 数组访问（如 `int arr[10]; int* p = arr;`）。
  - 数据结构（如链表、树）。

- **栈指针**：
  - 函数调用时保存返回地址。
  - 局部变量的分配和释放。
  - 保存函数调用的上下文（如寄存器值）。

#### 4. **生命周期**
- **指针**：
  - 由程序员显式分配和释放（如 `new`/`delete` 或 `malloc`/`free`）。
  - 示例：
    ```cpp
    int* p = new int(10);
    delete p; // 显式释放内存
    ```

- **栈指针**：
  - 由编译器自动管理。
  - 函数调用时自动调整栈指针。
  - 示例：
    - 函数调用时，栈指针下移。
    - 函数返回时，栈指针上移。

#### 5. **抽象层次**
- **指针**：
  - 高级语言特性，程序员可以直接使用。
  - 示例：
    ```cpp
    int a = 10;
    int* p = &a; // 直接使用指针
    ```

- **栈指针**：
  - 低级硬件特性，通常由编译器自动处理。
  - 示例：
    - 在汇编语言中，程序员可以直接操作栈指针。


### **四、示例**
#### 1. **指针示例**
```cpp
#include <iostream>

int main() {
    int a = 10;
    int* p = &a; // p 是指向 a 的指针
    std::cout << *p << std::endl; // 输出 10
    return 0;
}
```

#### 2. **栈指针示例**
```cpp
#include <iostream>

void func() {
    int b = 20; // 局部变量，分配在栈上
    std::cout << b << std::endl;
}

int main() {
    int a = 10; // 局部变量，分配在栈上
    func();
    return 0;
}
```
- **栈指针的作用**：
  - `main()` 函数调用时，栈指针下移，为 `a` 分配空间。
  - `func()` 函数调用时，栈指针再次下移，为 `b` 分配空间。
  - 函数返回时，栈指针上移，释放局部变量。


### **五、总结**
- **指针**：
  - 用于访问和操作内存中的数据。
  - 存储在内存中，由程序员显式管理。
- **栈指针**：
  - 用于管理函数调用栈。
  - 存储在 CPU 寄存器中，由编译器自动管理。

--- 

## 堆和栈
在 C++ 中，**堆（Heap）** 和 **栈（Stack）** 是两种不同的内存区域，用于存储程序运行时的数据。它们在内存管理、生命周期和访问方式上有显著区别。以下是它们的详细对比：


### 一、堆和栈的定义
#### 1. **栈（Stack）**
- 栈是一种后进先出（LIFO）的内存结构，由编译器自动管理。
- 栈用于存储局部变量、函数参数和函数调用的上下文（如返回地址）。

#### 2. **堆（Heap）**
- 堆是一种动态分配的内存区域，由程序员手动管理（或通过智能指针自动管理）。
- 堆用于存储动态分配的对象和数据结构。


### 二、核心区别
| **特性**               | **栈**                                | **堆**                                |
|------------------------|----------------------------------------|---------------------------------------|
| **内存管理**           | 编译器自动管理                         | 程序员手动管理（或智能指针）          |
| **生命周期**           | 随函数调用结束自动释放                 | 显式释放（或程序结束时释放）          |
| **分配速度**           | 快（只需移动栈指针）                   | 慢（需查找合适的内存块）              |
| **内存大小**           | 较小（通常几 MB）                      | 较大（受系统内存限制）                |
| **访问方式**           | 直接访问（通过栈指针）                 | 间接访问（通过指针）                  |
| **碎片问题**           | 无碎片                                 | 可能有内存碎片                        |
| **适用场景**           | 局部变量、函数调用                     | 动态分配的对象、大数据结构            |


### 三、详细对比
#### 1. **内存管理**
- **栈**：
  - 内存由编译器自动分配和释放。
  - 栈的大小有限，通常为几 MB（可通过编译器选项调整）。
- **堆**：
  - 内存由程序员手动分配（如 `new`/`malloc`）和释放（如 `delete`/`free`）。
  - 堆的大小受系统内存限制，通常较大。

#### 2. **生命周期**
- **栈**：
  - 变量的生命周期与函数调用绑定。
  - 函数调用结束时，栈上的变量自动释放。
- **堆**：
  - 变量的生命周期由程序员控制。
  - 必须显式释放内存，否则会导致内存泄漏。

#### 3. **分配速度**
- **栈**：
  - 分配速度快，只需移动栈指针。
- **堆**：
  - 分配速度较慢，需查找合适的内存块。

#### 4. **访问方式**
- **栈**：
  - 直接访问，通过栈指针定位变量。
- **堆**：
  - 间接访问，通过指针定位变量。

#### 5. **碎片问题**
- **栈**：
  - 无内存碎片问题，内存分配和释放是连续的。
- **堆**：
  - 可能有内存碎片问题，频繁分配和释放会导致内存不连续。

#### 6. **适用场景**
- **栈**：
  - 适合存储局部变量、函数参数和函数调用的上下文。
  - 适合生命周期短、大小固定的数据。
- **堆**：
  - 适合存储动态分配的对象和数据结构。
  - 适合生命周期长、大小不固定的数据。


### 四、示例对比
#### 1. **栈示例**
```cpp
void stackExample() {
    int a = 10; // 局部变量，存储在栈上
    int b = 20;
    int c = a + b;
    // 函数结束时，a、b、c 自动释放
}
```

#### 2. **堆示例**
```cpp
void heapExample() {
    int* a = new int(10); // 动态分配内存，存储在堆上
    int* b = new int(20);
    int* c = new int(*a + *b);
    // 必须显式释放内存
    delete a;
    delete b;
    delete c;
}
```


### 五、常见问题
#### 1. **栈溢出（Stack Overflow）**
- 当栈空间不足时（如递归调用过深），会导致栈溢出。
- 解决方法：
  - 减少栈空间的使用（如减少局部变量的大小）。
  - 将递归改为迭代。

#### 2. **内存泄漏（Memory Leak）**
- 当堆上的内存未释放时，会导致内存泄漏。
- 解决方法：
  - 使用智能指针（如 `std::unique_ptr`、`std::shared_ptr`）自动管理内存。
  - 确保每次 `new` 都有对应的 `delete`。

#### 3. **内存碎片（Memory Fragmentation）**
- 频繁分配和释放堆内存会导致内存碎片。
- 解决方法：
  - 使用内存池（Memory Pool）减少碎片。
  - 避免频繁分配和释放小块内存。


### 六、总结
- **栈**：
  - 适合存储局部变量和函数调用的上下文。
  - 内存由编译器自动管理，分配速度快，但大小有限。
- **堆**：
  - 适合存储动态分配的对象和数据结构。
  - 内存由程序员手动管理，分配速度慢，但大小较大。

在实际开发中，应根据数据的生命周期和大小选择合适的存储区域：
- 生命周期短、大小固定的数据适合存储在 **栈** 上。
- 生命周期长、大小不固定的数据适合存储在 **堆** 上。

---
## 为什么栈向下增长
栈（Stack）向下增长是一种常见的设计选择，主要是为了与堆（Heap）的内存分配方式形成互补，从而更高效地利用内存空间。以下是栈向下增长的主要原因和背景：


### 1. **内存布局**
在典型的进程内存布局中，内存被划分为多个区域：
- **栈（Stack）**：用于存储函数调用的上下文（如局部变量、返回地址等）。
- **堆（Heap）**：用于动态内存分配（如 `malloc` 或 `new`）。
- **数据段（Data Segment）**：存储全局变量和静态变量。
- **代码段（Code Segment）**：存储程序的可执行代码。

栈和堆通常位于进程地址空间的两端：
- 栈从高地址向低地址增长。
- 堆从低地址向高地址增长。

这种布局可以最大限度地利用内存空间，避免栈和堆之间的冲突。


### 2. **栈向下增长的原因**
#### （1）**历史原因**
- 早期的计算机系统设计者选择栈向下增长，主要是为了简化内存管理。
- 栈向下增长的设计与硬件架构（如 x86）的调用约定（Calling Convention）密切相关。

#### （2）**与堆的互补**
- 堆通常向上增长（从低地址向高地址），而栈向下增长（从高地址向低地址）。
- 这种设计使得栈和堆可以共享同一块内存空间，动态调整边界，从而更高效地利用内存。

#### （3）**简化内存管理**
- 栈向下增长的设计使得栈指针（Stack Pointer）的调整更加简单。
- 每次函数调用时，栈指针减小（向低地址移动），为新的栈帧分配空间；函数返回时，栈指针增加（向高地址移动），释放栈帧。

#### （4）**硬件支持**
- 许多处理器架构（如 x86）对栈向下增长有硬件支持。
- 例如，x86 的 `PUSH` 和 `POP` 指令会自动调整栈指针（`ESP` 或 `RSP`），并遵循向下增长的规则。


### 3. **栈向下增长的实现**
- **栈指针（Stack Pointer）**：指向栈的当前顶部。
- **栈帧（Stack Frame）**：每次函数调用时，会在栈上分配一个栈帧，用于存储局部变量、返回地址等信息。
- **增长方向**：栈指针向低地址移动表示栈的增长。

#### 示例：
```c
void func() {
    int a = 10; // 局部变量，存储在栈中
    // 栈指针向低地址移动
}
```


### 4. **栈向下增长的优点**
#### （1）**高效的内存利用**
- 栈和堆分别从内存的两端向中间增长，可以最大限度地利用内存空间。
- 当栈和堆的边界相遇时，系统可以检测到内存不足。

#### （2）**简单的指针管理**
- 栈指针的调整（增加或减少）与栈的增长方向一致，逻辑清晰。
- 函数调用和返回时，栈指针的调整非常直观。

#### （3）**硬件优化**
- 许多处理器架构对栈向下增长有专门的优化，例如 x86 的 `PUSH` 和 `POP` 指令。


### 5. **栈向下增长的缺点**
- **容易溢出**：如果栈增长过多，可能会覆盖堆或其他内存区域，导致栈溢出（Stack Overflow）。
- **调试困难**：栈向下增长的方向与人类的直觉相反，可能会增加调试的难度。


### 6. **总结**
栈向下增长的设计主要是为了：
1. 与堆的内存分配方式互补，高效利用内存空间。
2. 简化栈指针的管理和硬件实现。
3. 遵循历史惯例和硬件架构的支持。

---
## `int* ptr;`  分配在堆上还是栈上
在 C++ 中，声明 `int* ptr;` 时，指针变量 `ptr` **本身**的存储位置取决于它的作用域和声明方式：


### **1. `ptr` 变量本身的存储位置**
- **局部变量（函数内部声明）**：  
  如果 `ptr` 是在函数内部声明的局部变量（例如在函数体或代码块中），则 `ptr` **分配在栈上**。  
  栈内存由编译器自动管理，函数返回时自动释放。

- **全局变量或静态变量**：  
  如果 `ptr` 是全局变量或静态变量（例如用 `static` 修饰），则 `ptr` **分配在静态存储区**（数据段）。  
  静态存储区的内存在程序启动时分配，程序结束时释放。

### **2. `ptr` 指向的内存的存储位置**
`ptr` 是一个指针变量，它的值是某个内存地址。这个地址指向的内存位置取决于如何分配内存：
- **未初始化时**：  
  `ptr` 的值是未定义的（野指针），可能指向非法地址，直接使用会导致未定义行为（UB）。

- **指向栈内存**：  
  如果 `ptr` 指向另一个局部变量（例如 `int a; ptr = &a;`），则它指向**栈内存**。

- **指向堆内存**：  
  如果通过 `new` 或 `malloc` 分配内存（例如 `ptr = new int;`），则它指向**堆内存**。  
  堆内存需要手动管理（使用 `delete` 或 `free` 释放）。


### **关键总结**
| **场景**                     | `ptr` 变量本身的存储位置 | `ptr` 指向的内存位置        |
|------------------------------|--------------------------|-----------------------------|
| **局部指针变量**（如函数内部）| 栈                       | 未初始化时为野指针，可能非法 |
| `ptr = &stack_var;`           | 栈                       | 栈（指向其他局部变量）       |
| `ptr = new int;`              | 栈                       | 堆                          |
| **全局/静态指针变量**         | 静态存储区               | 取决于如何分配               |


### **示例代码**
#### （1）指针变量在栈上，指向栈内存：
```cpp
void func() {
    int a = 10;        // a 在栈上
    int* ptr = &a;     // ptr 在栈上，指向栈上的 a
} // 函数结束时，ptr 和 a 自动释放
```

#### （2）指针变量在栈上，指向堆内存：
```cpp
void func() {
    int* ptr = new int(10);  // ptr 在栈上，指向堆上的 int
    delete ptr;              // 必须手动释放堆内存
} // 函数结束时，ptr 自动释放，但堆内存需提前手动释放
```

#### （3）全局指针变量：
```cpp
int* global_ptr;        // global_ptr 在静态存储区

void func() {
    global_ptr = new int(10);  // 指向堆内存
}
// 程序结束时，global_ptr 的指针变量自动释放，但堆内存需手动释放（否则内存泄漏）
```


### **常见误区**
- **混淆指针本身和指针指向的内存**：  
  指针变量（如 `ptr`）本身是一个存储地址的变量，它的存储位置（栈、静态区）和它指向的内存位置（栈、堆）是独立的。

- **忘记释放堆内存**：  
  如果 `ptr` 指向堆内存但未释放，会导致内存泄漏。


### **结论**
- **`int* ptr;` 本身分配在栈或静态区**，具体取决于声明位置。  
- **`ptr` 指向的内存位置**取决于是否初始化及如何分配。  
- **必须手动管理堆内存**（通过 `new`/`delete` 或 `malloc`/`free`）。

---
## new vs malloc
在 C++ 中，`new` 和 `malloc` 都用于动态内存分配，但它们在行为、安全性和适用场景上有显著差异。以下是它们的详细对比：

### **1. 基本概念**
- **`new`**  
  - **C++ 运算符**：用于动态分配内存并调用对象的构造函数。
  - **类型安全**：返回具体类型的指针（如 `int*`）。
  - **与 `delete` 配对**：释放内存并调用析构函数。

- **`malloc`**  
  - **C 标准库函数**：仅分配原始内存块，不初始化对象。
  - **类型不安全**：返回 `void*`，需显式类型转换。
  - **与 `free` 配对**：仅释放内存，不调用析构函数。


### **2. 内存分配与初始化**
| 特性                | `new`                            | `malloc`                        |
|---------------------|----------------------------------|---------------------------------|
| **内存分配**        | 自动计算所需内存大小（如 `new int`）。 | 需手动指定大小（如 `malloc(sizeof(int))`）。 |
| **初始化对象**      | 调用构造函数。                   | 不调用构造函数，需手动初始化（如使用 `placement new`）。 |
| **示例**            | `int* p = new int(42);`          | `int* p = (int*)malloc(sizeof(int)); *p = 42;` |


### **3. 内存释放**
| 特性                | `delete`                         | `free`                          |
|---------------------|----------------------------------|---------------------------------|
| **析构函数调用**    | 调用析构函数。                   | 不调用析构函数。                |
| **资源管理**        | 确保对象资源（如内存、句柄）正确释放。 | 可能导致资源泄漏（如未释放内部资源）。 |
| **示例**            | `delete p;`                      | `free(p);`                      |


### **4. 类型安全**
| 特性                | `new`                            | `malloc`                        |
|---------------------|----------------------------------|---------------------------------|
| **返回类型**        | 具体类型指针（如 `int*`）。      | `void*`，需强制类型转换。       |
| **编译器检查**      | 类型匹配由编译器保证。           | 无类型检查，易出错。            |


### **5. 异常处理**
| 特性                | `new`                            | `malloc`                        |
|---------------------|----------------------------------|---------------------------------|
| **失败行为**        | 抛出 `std::bad_alloc` 异常。     | 返回 `NULL`，需手动检查。       |
| **错误处理**        | 可用 `try-catch` 捕获异常。      | 需检查返回值是否为 `NULL`。     |


### **6. 适用场景**
| 场景                | `new`                            | `malloc`                        |
|---------------------|----------------------------------|---------------------------------|
| **C++ 对象**        | ✅ 优先使用（自动构造/析构）。    | ❌ 需手动管理构造/析构。        |
| **原始内存分配**    | 可用（如 `new char[size]`）。    | ✅ 适用（如底层内存操作）。      |
| **与 C 代码交互**   | ❌ 不兼容。                      | ✅ 兼容 C 代码。                |


### **7. 性能与灵活性**
| 特性                | `new`                            | `malloc`                        |
|---------------------|----------------------------------|---------------------------------|
| **性能**            | 稍慢（需调用构造函数）。         | 较快（仅分配内存）。            |
| **重载支持**        | ✅ 可重载 `new`/`delete` 运算符。 | ❌ 无法重载。                   |


### **代码示例对比**
#### 使用 `new` 和 `delete`：
```cpp
class MyClass {
public:
    MyClass() { std::cout << "构造函数调用\n"; }
    ~MyClass() { std::cout << "析构函数调用\n"; }
};

int main() {
    MyClass* obj = new MyClass();  // 分配内存 + 调用构造函数
    delete obj;                    // 调用析构函数 + 释放内存
    return 0;
}
```

#### 使用 `malloc` 和 `free`：
```cpp
class MyClass {
public:
    MyClass() { std::cout << "构造函数调用\n"; }
    ~MyClass() { std::cout << "析构函数调用\n"; }
};

int main() {
    MyClass* obj = (MyClass*)malloc(sizeof(MyClass));  // 仅分配内存
    if (obj) {
        new(obj) MyClass();  // 手动调用构造函数（placement new）
        obj->~MyClass();     // 手动调用析构函数
        free(obj);           // 释放内存
    }
    return 0;
}
```


### **总结**
- **优先使用 `new` 和 `delete`**：  
  在 C++ 中，`new` 和 `delete` 提供了类型安全、自动构造/析构、异常处理等特性，适合管理对象生命周期。
  
- **谨慎使用 `malloc` 和 `free`**：  
  仅在需要与 C 代码交互、处理原始内存或实现底层内存管理时使用，需手动管理构造/析构和类型转换。

| **特性**       | `new`/`delete`              | `malloc`/`free`          |
|----------------|-----------------------------|--------------------------|
| **类型安全**   | ✅                          | ❌（需类型转换）         |
| **构造/析构**  | 自动调用                    | 需手动管理              |
| **异常处理**   | 支持异常                    | 返回 `NULL`             |
| **适用场景**   | C++ 对象动态分配            | 原始内存或 C 兼容场景   |

在 C++ 开发中，除非有特殊需求，否则应始终优先使用 `new` 和 `delete`。

---
## 动态内存
动态内存是程序在运行时手动分配和释放的内存，用于在不确定数据量或需要灵活管理内存的情况下存储数据。以下是对动态内存的详细解析：


### **一、动态内存的核心概念**
1. **与静态内存的区别**：
   - **静态内存**：在编译时分配，生命周期与程序一致（如全局变量）。
   - **栈内存**：函数调用时自动分配，函数返回时自动释放（如局部变量）。
   - **动态内存**：在运行时手动分配，需显式释放（如 `new`/`delete` 或 `malloc`/`free`）。

2. **核心特点**：
   - **灵活性**：按需分配，适合数据大小未知的场景（如动态数组）。
   - **生命周期可控**：由程序员决定内存的创建和销毁时机。
   - **作用域无关**：内存的存活不受函数调用栈的限制。


### **二、动态内存的操作方法**
#### 1. **C 语言中的动态内存**
   - **分配内存**：`malloc`、`calloc`
     ```c
     int* arr = (int*)malloc(10 * sizeof(int));  // 分配 10 个 int 的空间
     ```
   - **释放内存**：`free`
     ```c
     free(arr);  // 释放内存
     ```

#### 2. **C++ 中的动态内存**
   - **分配内存**：`new`
     ```cpp
     int* num = new int(42);       // 分配单个 int 并初始化为 42
     int* arr = new int[10];       // 分配 10 个 int 的动态数组
     ```
   - **释放内存**：`delete`
     ```cpp
     delete num;   // 释放单个对象
     delete[] arr; // 释放数组
     ```

#### 3. **智能指针（C++11+）**
   - **`std::unique_ptr`**：独占所有权，自动释放内存。
     ```cpp
     std::unique_ptr<int> ptr = std::make_unique<int>(42);
     ```
   - **`std::shared_ptr`**：共享所有权（引用计数）。
     ```cpp
     std::shared_ptr<int> ptr1 = std::make_shared<int>(42);
     auto ptr2 = ptr1;  // 引用计数 +1
     ```


### **三、动态内存的优缺点**
| **优点**                | **缺点**                  |
|-------------------------|---------------------------|
| 按需分配，节省内存       | 手动管理复杂，易出错       |
| 支持大块内存操作         | 内存泄漏风险               |
| 生命周期完全可控         | 可能导致悬挂指针（野指针） |


### **四、动态内存的常见问题**
1. **内存泄漏**  
   - **原因**：分配后未释放。  
   - **示例**：
     ```cpp
     void leak() {
         int* ptr = new int(10); // 未调用 delete
     }
     ```
   - **解决**：使用智能指针或内存检测工具（如 Valgrind）。

2. **悬挂指针（Dangling Pointer）**  
   - **原因**：释放内存后仍保留指针。  
   - **示例**：
     ```cpp
     int* ptr = new int(10);
     delete ptr;
     *ptr = 20; // 危险！ptr 指向已释放内存
     ```
   - **解决**：释放后置指针为 `nullptr`。

3. **重复释放**  
   - **原因**：多次释放同一块内存。  
   - **示例**：
     ```cpp
     int* ptr = new int(10);
     delete ptr;
     delete ptr; // 运行时崩溃
     ```


### **五、动态内存的应用场景**
1. **动态数据结构**  
   - 链表、树、图等需要动态扩展的结构。
     ```cpp
     struct Node {
         int data;
         Node* next;
     };
     Node* head = new Node{1, nullptr};
     ```

2. **大文件或数据流处理**  
   - 读取未知大小的文件到内存缓冲区。
     ```cpp
     std::ifstream file("data.bin", std::ios::binary);
     file.seekg(0, std::ios::end);
     size_t size = file.tellg();
     char* buffer = new char[size]; // 按文件大小分配内存
     ```

3. **多态对象管理**  
   - 基类指针指向派生类对象。
     ```cpp
     class Animal { public: virtual ~Animal() {} };
     class Dog : public Animal {};
     Animal* pet = new Dog();
     delete pet; // 正确调用 Dog 的析构函数（需虚析构）
     ```

### **六、最佳实践**
1. **优先使用智能指针**  
   - 避免手动 `new`/`delete`，减少内存泄漏风险。
     ```cpp
     auto ptr = std::make_unique<int[]>(100); // 自动管理动态数组
     ```

2. **RAII（资源获取即初始化）**  
   - 将资源绑定到对象生命周期。
     ```cpp
     class FileHandler {
     public:
         FileHandler(const char* path) : file(fopen(path, "r")) {}
         ~FileHandler() { if (file) fclose(file); }
     private:
         FILE* file;
     };
     ```

3. **检测工具辅助**  
   - 使用 Valgrind（Linux）、AddressSanitizer（Clang/GCC）或 Visual Studio 诊断工具检测内存问题。


### **总结**
动态内存赋予程序灵活管理内存的能力，但需谨慎操作以避免泄漏和指针错误。现代 C++ 通过智能指针和 RAII 机制大幅简化了内存管理，是高效编程的关键。

---
## mutex vs shared_mutex
**`mutex`** 和 **`shared_mutex`** 是 C++ 标准库中用于实现线程同步的两种锁机制，它们的主要区别在于锁的粒度和适用场景。以下是它们的详细对比：


### **一、基本概念**
#### 1. **`mutex`（互斥锁）**
- **功能**：提供独占访问，同一时间只有一个线程可以持有锁。
- **适用场景**：保护临界区，防止多个线程同时访问共享资源。

#### 2. **`shared_mutex`（共享互斥锁）**
- **功能**：支持两种模式：
  - **独占模式**：同一时间只有一个线程可以持有锁（类似于 `mutex`）。
  - **共享模式**：多个线程可以同时持有锁（适用于读多写少的场景）。
- **适用场景**：读多写少的场景，允许多个线程同时读取共享资源。


### **二、核心区别**
| **特性**               | **`mutex`**                          | **`shared_mutex`**                  |
|------------------------|----------------------------------------|-------------------------------------|
| **锁模式**             | 独占模式                               | 独占模式 + 共享模式                 |
| **适用场景**           | 通用场景                               | 读多写少的场景                     |
| **性能**               | 简单高效                               | 读操作性能更高                     |
| **C++ 标准**           | C++11                                  | C++17                              |
| **常用操作**           | `lock()`、`unlock()`、`try_lock()`     | `lock()`、`unlock()`、`try_lock()`、`lock_shared()`、`unlock_shared()`、`try_lock_shared()` |


### **三、详细对比**
#### 1. **锁模式**
- **`mutex`**：
  - 只支持独占模式，同一时间只有一个线程可以持有锁。
  - 示例：
    ```cpp
    std::mutex mtx;
    mtx.lock();   // 加锁
    // 临界区
    mtx.unlock(); // 解锁
    ```

- **`shared_mutex`**：
  - 支持两种模式：
    - **独占模式**：同一时间只有一个线程可以持有锁（用于写操作）。
    - **共享模式**：多个线程可以同时持有锁（用于读操作）。
  - 示例：
    ```cpp
    std::shared_mutex smtx;
    smtx.lock_shared(); // 共享模式加锁（读操作）
    // 读操作
    smtx.unlock_shared(); // 共享模式解锁

    smtx.lock(); // 独占模式加锁（写操作）
    // 写操作
    smtx.unlock(); // 独占模式解锁
    ```

#### 2. **适用场景**
- **`mutex`**：
  - 适用于通用场景，保护临界区。
  - 示例：
    ```cpp
    std::mutex mtx;
    int shared_data = 0;

    void increment() {
        mtx.lock();
        ++shared_data;
        mtx.unlock();
    }
    ```

- **`shared_mutex`**：
  - 适用于读多写少的场景，允许多个线程同时读取共享资源。
  - 示例：
    ```cpp
    std::shared_mutex smtx;
    int shared_data = 0;

    void read_data() {
        smtx.lock_shared();
        int value = shared_data;
        smtx.unlock_shared();
    }

    void write_data() {
        smtx.lock();
        ++shared_data;
        smtx.unlock();
    }
    ```

#### 3. **性能**
- **`mutex`**：
  - 简单高效，适合通用场景。
  - 但在读多写少的场景中，性能较差（读操作也需要独占锁）。

- **`shared_mutex`**：
  - 在读多写少的场景中，性能更高（允许多个线程同时读取）。
  - 但在写操作频繁的场景中，性能可能不如 `mutex`。

#### 4. **C++ 标准**
- **`mutex`**：
  - 从 C++11 开始支持。
- **`shared_mutex`**：
  - 从 C++17 开始支持。


### **四、示例代码**
#### 1. **`mutex` 示例**
```cpp
#include <iostream>
#include <thread>
#include <mutex>

std::mutex mtx;
int shared_data = 0;

void increment() {
    for (int i = 0; i < 100000; ++i) {
        mtx.lock();
        ++shared_data;
        mtx.unlock();
    }
}

int main() {
    std::thread t1(increment);
    std::thread t2(increment);

    t1.join();
    t2.join();

    std::cout << "Shared data: " << shared_data << std::endl;
    return 0;
}
```

#### 2. **`shared_mutex` 示例**
```cpp
#include <iostream>
#include <thread>
#include <shared_mutex>

std::shared_mutex smtx;
int shared_data = 0;

void read_data() {
    for (int i = 0; i < 100000; ++i) {
        smtx.lock_shared();
        int value = shared_data;
        smtx.unlock_shared();
    }
}

void write_data() {
    for (int i = 0; i < 100000; ++i) {
        smtx.lock();
        ++shared_data;
        smtx.unlock();
    }
}

int main() {
    std::thread t1(read_data);
    std::thread t2(write_data);

    t1.join();
    t2.join();

    std::cout << "Shared data: " << shared_data << std::endl;
    return 0;
}
```


### **五、总结**
- **`mutex`**：
  - 适用于通用场景，提供独占访问。
  - 简单高效，但在读多写少的场景中性能较差。
- **`shared_mutex`**：
  - 适用于读多写少的场景，支持共享模式。
  - 在读操作频繁的场景中性能更高。
--- 
## vector 
在 C++ 中，`std::vector` 是标准模板库（STL）提供的动态数组容器，支持自动扩容、随机访问和高效的内存管理。以下是详细的中文解析：


### 1. **头文件与声明**
   ```cpp
   #include <vector>  // 必须包含头文件
   using namespace std; // 可选，简化代码

   vector<int> vec;                // 空整数向量
   vector<string> names{"Alice", "Bob"}; // 初始化包含字符串的向量
   vector<double> scores(5);       // 包含5个double元素的向量（默认初始化为0.0）
   ```


### 2. **核心操作**
   - **添加元素**：
     ```cpp
     vec.push_back(10);    // 在末尾添加元素（拷贝构造）
     vec.emplace_back(20); // 在末尾就地构造元素（更高效，C++11起支持）
     ```
   - **访问元素**：
     ```cpp
     int first = vec[0];      // 通过下标访问（无越界检查）
     int second = vec.at(1);  // 通过at()访问（越界时抛出std::out_of_range异常）
     int last = vec.back();   // 获取最后一个元素
     ```
   - **删除元素**：
     ```cpp
     vec.pop_back();          // 删除最后一个元素
     vec.erase(vec.begin());  // 删除第一个元素（需用迭代器）
     vec.clear();             // 清空所有元素
     ```
   - **容量管理**：
     ```cpp
     int size = vec.size();     // 当前元素个数
     bool isEmpty = vec.empty(); // 判断是否为空
     vec.reserve(100);          // 预分配至少容纳100个元素的内存
     vec.shrink_to_fit();       // 释放未使用的内存（C++11+）
     ```


### 3. **遍历方式**
   ```cpp
   // 范围for循环（C++11+）
   for (const auto& num : vec) {
       cout << num << endl;
   }

   // 迭代器遍历
   for (auto it = vec.begin(); it != vec.end(); ++it) {
       cout << *it << endl;
   }
   ```


### 4. **性能特点**
   - **随机访问**：时间复杂度为 O(1)（与数组相同）。
   - **尾部插入/删除**：平均时间复杂度为 O(1)（自动扩容时可能有短暂延迟）。
   - **中间插入/删除**：时间复杂度为 O(n)（需要移动后续元素）。
   - **内存特性**：连续内存布局，缓存友好，但频繁扩容可能导致性能开销。


### 5. **适用场景**
   - 需要动态调整大小的数组。
   - 高频随机访问元素的场景。
   - 需要与C风格接口交互时（通过 `vec.data()` 获取原始指针）。


### 6. **示例代码**
   ```cpp
   #include <iostream>
   #include <vector>
   using namespace std;

   int main() {
       vector<int> nums{1, 2, 3};
       nums.push_back(4);

       cout << "元素列表: ";
       for (int num : nums) {
           cout << num << " "; // 输出: 1 2 3 4
       }

       nums.pop_back(); // 删除末尾元素4
       cout << "\n删除后的大小: " << nums.size(); // 输出: 3
       return 0;
   }
   ```


### 7. **最佳实践**
   - **预分配内存**：已知元素数量时，用 `reserve()` 减少扩容次数。
   - **优先使用 `emplace_back`**：避免不必要的对象拷贝。
   - **避免值传递**：函数参数使用引用传递以提升性能，如：  
     `void process(const vector<int>& data) { ... }`


### 8. **与其他容器的对比**
   - **`std::list`**：适合频繁在中间插入/删除，但无法随机访问。
   - **`std::deque`**：支持高效的头尾插入，但内存不连续。


`std::vector` 是 C++ 中最常用的容器之一，兼具灵活性与性能。建议在需要动态数组时优先选择，但避免在中间频繁插入/删除的场景。

---
## C++ push_back 左值和右值的区别
在C++中，`push_back` 是 `std::vector` 的一个成员函数，用于在向量的末尾添加一个元素。`push_back` 可以接受左值和右值作为参数，它们的处理方式有所不同。

### 1. 左值 (Lvalue)
左值是指具有明确内存地址的表达式，通常是可以取地址的变量或对象。当使用左值调用 `push_back` 时，会调用 `push_back` 的左值重载版本，该版本会复制或拷贝构造传入的对象。

```cpp
std::vector<int> vec;
int x = 10;
vec.push_back(x);  // x 是左值，调用 push_back(const T& value)
```

在这个例子中，`x` 是一个左值，`push_back` 会将 `x` 的值复制到 `vec` 中。

### 2. 右值 (Rvalue)
右值是指临时对象或即将被销毁的对象，通常是不能取地址的表达式。当使用右值调用 `push_back` 时，会调用 `push_back` 的右值重载版本，该版本会移动构造传入的对象。

```cpp
std::vector<int> vec;
vec.push_back(10);  // 10 是右值，调用 push_back(T&& value)
```

在这个例子中，`10` 是一个右值，`push_back` 会将 `10` 的值移动到 `vec` 中，避免了不必要的复制操作。

### 3. 移动语义
C++11 引入了移动语义，允许将资源从一个对象转移到另一个对象，而不是复制它们。这对于管理动态内存或大型对象的容器非常有用，因为它可以显著提高性能。

```cpp
std::vector<std::string> vec;
std::string str = "Hello";
vec.push_back(str);  // str 是左值，调用 push_back(const T& value)，复制 str
vec.push_back(std::move(str));  // std::move(str) 是右值，调用 push_back(T&& value)，移动 str
```

在这个例子中，`std::move(str)` 将 `str` 转换为右值，`push_back` 会移动 `str` 的内容到 `vec` 中，而不是复制它。移动后，`str` 的状态是未定义的，通常不应该再使用它。

### 总结
- **左值**：调用 `push_back(const T& value)`，进行复制构造。
- **右值**：调用 `push_back(T&& value)`，进行移动构造。

---

## 移动语义
**移动语义**是 C++11 引入的一项重要特性，旨在提高程序的性能，特别是在处理动态内存或大型对象时。它允许将资源（如堆内存、文件句柄等）从一个对象“移动”到另一个对象，而不是进行昂贵的复制操作。

### 1. 核心思想
移动语义的核心思想是：当一个对象是临时对象（右值）或即将被销毁时，可以直接“窃取”它的资源，而不是复制这些资源。这样可以避免不必要的内存分配和复制操作，从而提高性能。

### 2. 右值和右值引用
- **右值（Rvalue）**：临时对象或即将被销毁的对象，例如字面量、临时变量或 `std::move` 的结果。
- **右值引用（Rvalue Reference）**：用 `&&` 表示，例如 `T&&`。右值引用可以绑定到右值，表示可以“窃取”该对象的资源。

### 3. 移动构造函数和移动赋值运算符
为了实现移动语义，C++11 引入了两种特殊的成员函数：
- **移动构造函数**：用于从一个右值对象“移动”资源。
- **移动赋值运算符**：用于在赋值时从一个右值对象“移动”资源。

#### 示例代码
```cpp
class MyString {
public:
    // 普通构造函数
    MyString(const char* str) {
        size = strlen(str);
        data = new char[size + 1];
        strcpy(data, str);
    }

    // 移动构造函数
    MyString(MyString&& other) noexcept {
        data = other.data;  // 窃取资源
        size = other.size;
        other.data = nullptr;  // 将原对象的指针置为空
        other.size = 0;
    }

    // 移动赋值运算符
    MyString& operator=(MyString&& other) noexcept {
        if (this != &other) {
            delete[] data;  // 释放当前对象的资源
            data = other.data;  // 窃取资源
            size = other.size;
            other.data = nullptr;  // 将原对象的指针置为空
            other.size = 0;
        }
        return *this;
    }

    // 析构函数
    ~MyString() {
        delete[] data;
    }

private:
    char* data;
    size_t size;
};
```

### 4. `std::move` 的作用
`std::move` 是一个工具函数，用于将左值强制转换为右值引用，从而允许调用移动构造函数或移动赋值运算符。

#### 示例
```cpp
MyString str1("Hello");
MyString str2 = std::move(str1);  // 调用移动构造函数
```

在这个例子中，`std::move(str1)` 将 `str1` 转换为右值引用，`str2` 会“窃取” `str1` 的资源。移动后，`str1` 的状态是未定义的，通常不应该再使用它。

### 5. 移动语义的优势
- **性能提升**：避免了不必要的资源复制，特别是对于动态内存、文件句柄等资源密集型对象。
- **支持高效资源管理**：例如 `std::vector`、`std::string` 等标准库容器和类都实现了移动语义，显著提高了性能。

### 6. 移动语义的应用场景
- **容器操作**：例如 `std::vector::push_back` 使用移动语义来高效添加元素。
- **返回值优化**：函数返回临时对象时，编译器会自动使用移动语义。
- **资源管理**：例如智能指针（`std::unique_ptr`）和文件流（`std::fstream`）等。

### 7. 注意事项
- **移动后的对象状态**：移动操作后，原对象的资源被“窃取”，其状态是未定义的。通常需要将原对象的指针置为 `nullptr`，以避免重复释放资源。
- **异常安全**：移动操作通常标记为 `noexcept`，以确保不会抛出异常。

### 总结
移动语义是 C++11 引入的一项重要特性，通过“窃取”临时对象的资源来避免不必要的复制操作，从而提升性能。它依赖于右值引用、移动构造函数和移动赋值运算符，并通过 `std::move` 显式触发移动操作。掌握移动语义对于编写高效的现代 C++ 代码至关重要。

---

## 什么情况下需要显示调用析构函数
在 C++ 中，**显式调用析构函数**是一种非常规的操作，通常只在特定情况下使用。大多数情况下，对象的析构函数会自动调用（例如，当对象离开作用域时，或者通过 `delete` 删除动态分配的对象时）。然而，在某些特殊场景下，可能需要显式调用析构函数。

以下是需要显式调用析构函数的常见情况：


### 1. **手动管理对象的生命周期**
在使用 **placement new**（定位 new）时，对象的构造函数被显式调用，但内存的分配和释放由程序员手动管理。此时，需要显式调用析构函数来销毁对象，而不会释放内存。

#### 示例
```cpp
#include <iostream>

class MyClass {
public:
    MyClass() { std::cout << "Constructor called!\n"; }
    ~MyClass() { std::cout << "Destructor called!\n"; }
};

int main() {
    // 分配内存，但不调用构造函数
    void* memory = malloc(sizeof(MyClass));

    // 使用 placement new 在已分配的内存上构造对象
    MyClass* obj = new(memory) MyClass;

    // 显式调用析构函数
    obj->~MyClass();

    // 释放内存
    free(memory);

    return 0;
}
```

**输出：**
```
Constructor called!
Destructor called!
```

**说明：**
- 使用 `placement new` 时，构造函数被显式调用，但内存的释放需要手动完成。
- 显式调用析构函数是为了正确销毁对象，而 `free` 是为了释放内存。


### 2. **自定义内存池或对象池**
在实现自定义内存池或对象池时，对象的创建和销毁由程序员完全控制。此时，可能需要显式调用析构函数来销毁对象，而不释放底层内存。

#### 示例
```cpp
class MyClass {
public:
    MyClass() { std::cout << "Constructor called!\n"; }
    ~MyClass() { std::cout << "Destructor called!\n"; }
};

class ObjectPool {
public:
    void* allocate() {
        return malloc(sizeof(MyClass));
    }

    void deallocate(void* ptr) {
        free(ptr);
    }
};

int main() {
    ObjectPool pool;

    // 分配内存
    void* memory = pool.allocate();

    // 构造对象
    MyClass* obj = new(memory) MyClass;

    // 显式调用析构函数
    obj->~MyClass();

    // 释放内存
    pool.deallocate(memory);

    return 0;
}
```


### 3. **处理未初始化内存**
在某些情况下，对象可能被分配到未初始化的内存中（例如，使用 `std::aligned_storage` 或 `std::vector` 的底层内存）。此时，需要显式调用析构函数来销毁对象。

#### 示例
```cpp
#include <iostream>
#include <type_traits>

class MyClass {
public:
    MyClass() { std::cout << "Constructor called!\n"; }
    ~MyClass() { std::cout << "Destructor called!\n"; }
};

int main() {
    // 分配未初始化内存
    std::aligned_storage<sizeof(MyClass), alignof(MyClass)>::type storage;

    // 构造对象
    MyClass* obj = new(&storage) MyClass;

    // 显式调用析构函数
    obj->~MyClass();

    return 0;
}
```


### 4. **优化性能**
在某些高性能场景中，可能需要手动控制对象的生命周期，以避免不必要的析构函数调用。例如，在复用对象时，可以显式调用析构函数来重置对象状态。


### 5. **处理低级数据结构**
在处理低级数据结构（如 `union` 或 `std::variant`）时，可能需要显式调用析构函数来销毁当前活动的对象。

#### 示例
```cpp
#include <iostream>
#include <variant>

class MyClass {
public:
    MyClass() { std::cout << "Constructor called!\n"; }
    ~MyClass() { std::cout << "Destructor called!\n"; }
};

int main() {
    std::variant<int, MyClass> v;

    // 在 variant 中构造 MyClass 对象
    v.emplace<MyClass>();

    // 显式调用析构函数
    std::get<MyClass>(v).~MyClass();

    return 0;
}
```


### 6. **调试和测试**
在调试或测试时，可能需要显式调用析构函数来验证对象的销毁行为。


### 注意事项
1. **不要重复调用析构函数**：
   - 显式调用析构函数后，对象已经被销毁。再次调用析构函数会导致未定义行为。
   
2. **确保内存管理正确**：
   - 显式调用析构函数后，需要确保内存被正确释放（例如，使用 `free` 或自定义内存池的释放函数）。

3. **避免不必要的显式调用**：
   - 在大多数情况下，析构函数会自动调用，显式调用析构函数可能会导致资源泄漏或双重释放。


### 总结
显式调用析构函数的场景通常涉及手动管理内存或对象的生命周期，例如：
- 使用 `placement new` 时。
- 实现自定义内存池或对象池时。
- 处理未初始化内存时。
- 优化性能或调试时。

---

## 只调用析构函数，但没有释放内存会发生什么
在 C++ 中，**仅调用析构函数而不释放内存**会导致以下问题：


### **1. 资源泄漏**
- **析构函数的作用**：析构函数负责清理对象的资源（如动态内存、文件句柄、网络连接等）。
- **手动调用析构函数**：如果显式调用析构函数（如 `obj->~MyClass();`），但未释放对象内存：
  - **资源被提前释放**：析构函数会释放对象内部的资源（如 `delete[] data;`），但这些资源可能已被标记为“无效”。
  - **悬垂指针**：对象的内存未被释放，但其内部资源已被清理。后续若误用该对象，会导致访问无效内存（如野指针），引发 **未定义行为**（UB）。

#### 示例
```cpp
class MyClass {
public:
    MyClass() { data = new int[100]; }
    ~MyClass() { delete[] data; }
    int* data;
};

int main() {
    MyClass* obj = new MyClass();
    obj->~MyClass();  // 析构函数释放 data，但 obj 的内存未释放

    // 此时 obj->data 是悬垂指针
    // obj 的内存未释放，导致内存泄漏
    return 0;
}
```


### **2. 内存泄漏**
- **对象内存未释放**：通过 `new` 分配的内存未被 `delete` 回收，导致内存泄漏。
- **影响**：程序长时间运行后，内存泄漏累积可能导致性能下降或崩溃。


### **3. 重复析构（双重释放）**
- **手动析构后调用 `delete`**：若显式调用析构函数后，再调用 `delete obj`：
  - 析构函数会被再次调用，导致 **双重释放**（如重复 `delete[] data`），触发未定义行为（如程序崩溃）。

#### 示例
```cpp
MyClass* obj = new MyClass();
obj->~MyClass();  // 手动调用析构函数
delete obj;       // 再次调用析构函数 + 释放内存 → 双重释放 data
```


### **4. 对象状态失效**
- **析构后的对象无效**：析构函数执行后，对象内部状态被破坏（如指针置空、资源释放）。即使内存未被释放，对象也不再可用。
- **误用风险**：后续若访问该对象，可能导致逻辑错误或崩溃。


### **何时可以安全地仅调用析构函数？**
在特定场景下，**手动调用析构函数但不释放内存是合法的**，但需确保内存管理的正确性：

#### **使用 Placement New**
当对象通过 **placement new** 在预分配的内存上构造时，需手动调用析构函数，但无需释放内存（内存由外部管理）。

```cpp
#include <new>

char buffer[sizeof(MyClass)];  // 预分配内存（如栈内存）
MyClass* obj = new (buffer) MyClass();  // 在 buffer 上构造对象
obj->~MyClass();  // 手动调用析构函数，buffer 的内存由栈自动回收
```


### **总结**
| **操作**               | **后果**                                                                 |
|-------------------------|--------------------------------------------------------------------------|
| 仅调用析构函数不释放内存 | 资源泄漏（对象内部资源被释放但内存未回收）、内存泄漏、悬垂指针风险。       |
| 调用析构函数后再次释放   | 双重释放，导致未定义行为（如崩溃）。                                     |
| **安全场景**           | 使用 placement new 时，手动析构是合法的（内存由外部管理）。              |


### **最佳实践**
1. **避免手动调用析构函数**：除非使用 placement new 或自定义内存管理。
2. **配对使用 `new`/`delete`**：确保每个 `new` 对应一个 `delete`。
3. **使用智能指针**：如 `std::unique_ptr` 或 `std::shared_ptr`，自动管理资源生命周期。

---
## 析构函数的使用
在 C++ 中，析构函数（Destructor）负责在对象生命周期结束时释放其占用的资源，防止内存泄漏和资源泄露。以下是析构函数销毁的主要资源类型及其详细说明：


### **一、析构函数销毁的典型资源**
#### 1. **动态分配的内存**
   - **手动分配的内存**：通过 `new` 或 `new[]` 分配的堆内存。
     ```cpp
     class Example {
     private:
         int* data;
     public:
         Example() : data(new int[100]) {}
         ~Example() { delete[] data; } // 释放动态数组
     };
     ```

#### 2. **文件句柄（File Handles）**
   - 打开的文件、网络套接字等系统资源需显式关闭。
     ```cpp
     #include <fstream>
     class FileHandler {
     private:
         std::fstream file;
     public:
         FileHandler(const std::string& path) : file(path) {}
         ~FileHandler() { file.close(); } // 关闭文件
     };
     ```

#### 3. **数据库连接、网络连接**
   - 数据库连接池或网络会话需在析构时释放。
     ```cpp
     class DatabaseConnection {
     public:
         ~DatabaseConnection() { disconnect(); } // 断开数据库连接
     };
     ```

#### 4. **互斥锁（Mutex Locks）**
   - 确保锁在对象销毁时释放，避免死锁。
     ```cpp
     #include <mutex>
     class SafeCounter {
     private:
         std::mutex mtx;
         int count = 0;
     public:
         void increment() {
             std::lock_guard<std::mutex> lock(mtx);
             count++;
         }
         // 锁通过 RAII 自动释放，无需手动操作
     };
     ```

#### 5. **其他对象的成员**
   - 对象成员（如其他类实例）的析构函数会被自动调用。
     ```cpp
     class Inner { /* ... */ };
     class Outer {
     private:
         Inner inner; // 成员对象
     public:
         ~Outer() {
             // 先执行 Outer 的析构代码
             // 然后自动调用 Inner 的析构函数
         }
     };
     ```

#### 6. **基类资源**
   - 派生类析构时，先调用派生类的析构函数，再调用基类的析构函数。
     ```cpp
     class Base {
     public:
         virtual ~Base() {} // 虚析构函数确保正确释放派生类资源
     };
     class Derived : public Base {
     public:
         ~Derived() override {} // 先执行 Derived 的析构，再执行 Base 的析构
     };
     ```


### **二、析构函数 *不* 销毁的资源**
#### 1. **栈内存（局部变量）**
   - 栈内存由编译器自动管理，函数返回时自动回收。
     ```cpp
     void func() {
         int x = 42; // 栈内存，无需手动释放
     }
     ```

#### 2. **静态变量（Static Variables）**
   - 静态变量生命周期持续到程序结束，不受对象析构影响。
     ```cpp
     class Singleton {
     public:
         static Singleton& getInstance() {
             static Singleton instance; // 程序结束时自动析构
             return instance;
         }
     };
     ```

#### 3. **智能指针管理的资源**
   - `std::unique_ptr`、`std::shared_ptr` 等会在析构时自动释放资源。
     ```cpp
     class SafeData {
     private:
         std::unique_ptr<int[]> data;
     public:
         SafeData() : data(std::make_unique<int[]>(100)) {}
         // 无需手动释放，智能指针自动处理
     };
     ```


### **三、析构函数的调用规则**
1. **显式调用**  
   - 析构函数在以下情况被调用：
     - 对象离开作用域（如局部变量）。
     - `delete` 操作符作用于动态对象。
     - 容器（如 `std::vector`）销毁时调用元素的析构函数。
     - 异常栈展开时析构局部对象。

2. **隐式调用**  
   - 若未显式定义析构函数，编译器会生成默认析构函数，释放成员对象和基类资源。


### **四、最佳实践**
1. **RAII（资源获取即初始化）**  
   - 将资源绑定到对象生命周期，通过析构函数自动释放。
   - 示例：使用 `std::unique_ptr` 代替裸指针。

2. **避免在析构函数中抛出异常**  
   - C++ 析构函数若抛出未捕获的异常，程序可能直接终止。
   ```cpp
   ~Example() {
       try {
           // 释放资源
       } catch (...) {
           // 记录日志，但不要抛出
       }
   }
   ```

3. **虚析构函数**  
   - 基类应声明虚析构函数，确保多态对象正确释放。
   ```cpp
   class Base {
   public:
       virtual ~Base() = default; // 虚析构函数
   };
   ```


### **五、总结**
| **资源类型**       | **是否需要析构函数释放？** | **示例**                    |
|--------------------|---------------------------|-----------------------------|
| 动态内存（`new`）  | 是                        | `delete[] data;`            |
| 文件句柄           | 是                        | `file.close();`             |
| 互斥锁             | 否（RAII 自动释放）        | `std::lock_guard`           |
| 智能指针管理资源   | 否                        | `std::unique_ptr`           |
| 栈内存             | 否                        | 局部变量 `int x;`           |

**核心原则**：  
- 手动分配的资源必须手动释放。
- 优先使用 RAII 和智能指针，减少手动管理错误。

---
## 默认析构函数
在 C++ 中，**默认析构函数**是编译器自动生成的析构函数，当用户未显式定义时，它负责完成对象生命周期的收尾工作。以下是其核心作用和适用场景的详细解析：


### **一、默认析构函数的行为**
#### 1. **自动调用成员对象和基类的析构函数**
   - 若类的成员变量是其他类的对象（如 `std::string`、`std::vector`），默认析构函数会依次调用它们的析构函数。
   - 若类是派生类，默认析构函数会调用基类的析构函数。
   ```cpp
   class Base {
   public:
       ~Base() { std::cout << "Base destructor\n"; }
   };

   class Member {
   public:
       ~Member() { std::cout << "Member destructor\n"; }
   };

   class Derived : public Base {
   private:
       Member mem;
   public:
       // 默认析构函数会自动调用 Base::~Base() 和 Member::~Member()
   };

   int main() {
       Derived d; // 析构顺序：Derived 隐式析构 -> Member 析构 -> Base 析构
   }
   ```

#### 2. **不处理动态资源**
   - 默认析构函数**不会释放动态分配的内存（如 `new` 分配的指针成员）**。
   - 若类中有原始指针指向堆内存，必须自定义析构函数来释放资源，否则会导致内存泄漏。
   ```cpp
   class LeakyClass {
   private:
       int* data; // 原始指针
   public:
       LeakyClass() : data(new int[100]) {}
       // 默认析构函数不会释放 data，导致内存泄漏！
   };
   ```


### **二、何时可以使用默认析构函数？**
#### 1. **类的成员均为自动管理资源的类型**
   - 成员变量使用 **RAII 类型**（如 `std::string`、`std::vector`、智能指针等），其析构函数能自动释放资源。
   ```cpp
   class SafeClass {
   private:
       std::vector<int> vec;  // RAII 容器，自动管理内存
       std::unique_ptr<int> ptr; // 智能指针，自动释放内存
   public:
       // 默认析构函数足够，无需手动释放资源
   };
   ```

#### 2. **类没有动态分配的资源**
   - 若类的所有成员变量均为栈内存对象（如基本类型、结构体、非指针的类对象），默认析构函数足够。
   ```cpp
   class SimpleClass {
   private:
       int x;
       double y;
       std::string name; // RAII 类型，自动释放
   public:
       // 默认析构函数自动清理 x、y、name
   };
   ```

#### 3. **基类析构函数为虚函数**
   - 若类是多态基类（即可能被继承），需显式声明虚析构函数，但派生类若无需额外资源释放，仍可使用默认析构函数。
   ```cpp
   class Base {
   public:
       virtual ~Base() = default; // 虚析构函数
   };

   class Derived : public Base {
       // 默认析构函数会正确调用 Base::~Base()
   };
   ```


### **三、何时必须自定义析构函数？**
#### 1. **手动管理动态资源**
   - 类中包含 **原始指针**、文件句柄、网络连接等需显式释放的资源。
   ```cpp
   class FileHandler {
   private:
       FILE* file;
   public:
       FileHandler(const char* path) : file(fopen(path, "r")) {}
       ~FileHandler() { if (file) fclose(file); } // 必须手动关闭文件
   };
   ```

#### 2. **复杂资源管理**
   - 需要执行特定清理逻辑（如日志记录、状态回滚）。
   ```cpp
   class Transaction {
   public:
       ~Transaction() {
           if (!committed) {
               rollback(); // 事务未提交时回滚
           }
       }
   };
   ```

#### 3. **处理非 RAII 类型的资源**
   - 使用第三方库或 C 风格接口分配的资源（如 `malloc`、`sqlite3_open`）。
   ```cpp
   class CStyleResource {
   private:
       void* raw_mem;
   public:
       CStyleResource() : raw_mem(malloc(1024)) {}
       ~CStyleResource() { free(raw_mem); } // 必须手动释放
   };
   ```


### **四、默认析构函数的总结**
| **场景**                   | **是否可用默认析构函数？** | **原因**                                                                 |
|----------------------------|---------------------------|-------------------------------------------------------------------------|
| 成员变量为 RAII 类型         | 是                        | RAII 类型自动释放资源（如 `std::vector`、`std::unique_ptr`）              |
| 类无动态资源                | 是                        | 无手动管理需求，成员变量为基本类型或栈对象                                  |
| 基类析构函数为虚函数         | 是                        | 派生类默认析构函数正确调用基类析构函数                                       |
| 包含原始指针或非 RAII 资源   | 否                        | 需手动释放资源（如 `delete`、`fclose`、`free`）                            |


### **五、最佳实践**
1. **优先使用 RAII 类型**  
   用 `std::unique_ptr` 替代原始指针，用 `std::fstream` 替代 `FILE*`，减少手动资源管理。
2. **遵循“三/五/零法则”**  
   若自定义析构函数，通常需要同时定义拷贝构造函数、拷贝赋值运算符等（C++11 后可通过 `=default` 或 `=delete` 显式控制）。
3. **避免默认析构函数的陷阱**  
   若类可能被继承，将基类析构函数声明为虚函数，即使它是默认实现：
   ```cpp
   class Base {
   public:
       virtual ~Base() = default; // 虚析构函数
   };
   ```


---
## 构造函数都做了什么？ 一个对象在内存中怎么分布？
在 C++ 中，构造函数负责初始化对象的状态，确保对象在创建时处于有效和可用的状态。以下是构造函数的详细作用以及对象在内存中的分布情况：


### **一、构造函数的作用**
#### 1. **初始化成员变量**
   - 构造函数为对象的成员变量分配初始值。
   - 示例：
     ```cpp
     class Example {
     private:
         int x;
         std::string name;
     public:
         Example() : x(0), name("default") {} // 初始化列表
     };
     ```

#### 2. **分配动态资源**
   - 如果对象需要动态分配内存或其他资源（如文件句柄、网络连接），构造函数负责分配。
   - 示例：
     ```cpp
     class DynamicArray {
     private:
         int* data;
     public:
         DynamicArray(size_t size) : data(new int[size]) {}
         ~DynamicArray() { delete[] data; }
     };
     ```

#### 3. **执行初始化逻辑**
   - 构造函数可以包含复杂的初始化逻辑（如验证参数、加载配置文件）。
   - 示例：
     ```cpp
     class Database {
     public:
         Database(const std::string& configFile) {
             if (!loadConfig(configFile)) {
                 throw std::runtime_error("Failed to load config");
             }
         }
     };
     ```

#### 4. **调用基类和成员对象的构造函数**
   - 如果类是派生类，构造函数会先调用基类的构造函数。
   - 如果类包含成员对象，构造函数会调用成员对象的构造函数。
   - 示例：
     ```cpp
     class Base {
     public:
         Base() { std::cout << "Base constructor\n"; }
     };

     class Member {
     public:
         Member() { std::cout << "Member constructor\n"; }
     };

     class Derived : public Base {
     private:
         Member mem;
     public:
         Derived() { std::cout << "Derived constructor\n"; }
     };

     int main() {
         Derived d; // 输出顺序：Base -> Member -> Derived
     }
     ```

#### 5. **委托构造函数（C++11+）**
   - 一个构造函数可以调用另一个构造函数，避免代码重复。
   - 示例：
     ```cpp
     class Example {
     private:
         int x, y;
     public:
         Example() : Example(0, 0) {} // 委托构造函数
         Example(int a, int b) : x(a), y(b) {}
     };
     ```


### **二、对象在内存中的分布**
对象在内存中的分布取决于其成员变量、继承关系和内存对齐规则。以下是典型的内存布局：

#### 1. **普通类对象**
   - 成员变量按声明顺序存储。
   - 示例：
     ```cpp
     class Example {
     private:
         int x;       // 4 字节
         double y;    // 8 字节
         char z;      // 1 字节
     };
     ```
   - 内存布局（假设对齐为 8 字节）：
     ```
     +---------+---------+---------+---------+
     |   x     |  padding|    y    |    z    |
     +---------+---------+---------+---------+
     | 4 bytes | 4 bytes | 8 bytes | 1 byte  |
     +---------+---------+---------+---------+
     ```

#### 2. **继承类对象**
   - 基类成员在前，派生类成员在后。
   - 示例：
     ```cpp
     class Base {
     private:
         int x;
     };

     class Derived : public Base {
     private:
         double y;
     };
     ```
   - 内存布局：
     ```
     +---------+---------+
     |   x     |    y    |
     +---------+---------+
     | 4 bytes | 8 bytes |
     +---------+---------+
     ```

#### 3. **虚函数表（vtable）**
   - 如果类包含虚函数，编译器会生成虚函数表（vtable），并在对象中插入指向 vtable 的指针（vptr）。
   - 示例：
     ```cpp
     class Base {
     public:
         virtual void func() {}
     };

     class Derived : public Base {
     public:
         void func() override {}
     };
     ```
   - 内存布局：
     ```
     +---------+---------+
     |  vptr   |   x     |
     +---------+---------+
     | 8 bytes | 4 bytes |
     +---------+---------+
     ```

#### 4. **多继承对象**
   - 每个基类的成员按声明顺序存储，可能包含多个 vptr。
   - 示例：
     ```cpp
     class Base1 {
     public:
         virtual void func1() {}
     };

     class Base2 {
     public:
         virtual void func2() {}
     };

     class Derived : public Base1, public Base2 {
     public:
         void func1() override {}
         void func2() override {}
     };
     ```
   - 内存布局：
     ```
     +---------+---------+---------+---------+
     | vptr1   | Base1   | vptr2   | Base2   |
     +---------+---------+---------+---------+
     | 8 bytes | 4 bytes | 8 bytes | 4 bytes |
     +---------+---------+---------+---------+
     ```


### **三、内存对齐**
- **对齐规则**：编译器会根据平台和数据类型调整内存布局，以提高访问效率。
- **示例**：
  ```cpp
  class AlignedExample {
  private:
      char a;    // 1 字节
      int b;     // 4 字节
      double c;  // 8 字节
  };
  ```
  - 内存布局（假设对齐为 8 字节）：
    ```
    +---------+---------+---------+---------+
    |    a    | padding |    b    |    c    |
    +---------+---------+---------+---------+
    | 1 byte  | 3 bytes | 4 bytes | 8 bytes |
    +---------+---------+---------+---------+
    ```


### **四、总结**
| **构造函数的作用**         | **对象内存分布**               |
|----------------------------|--------------------------------|
| 初始化成员变量             | 成员变量按声明顺序存储         |
| 分配动态资源               | 基类成员在前，派生类成员在后   |
| 执行初始化逻辑             | 虚函数表指针（vptr）插入对象   |
| 调用基类和成员构造函数     | 内存对齐优化访问效率           |

---
## 类里的成员变量都分配在堆上吗
在 C++ 中，类成员变量的内存分配位置（堆或栈）取决于对象的创建方式以及成员变量本身的类型。以下是详细解析：


### **一、成员变量的内存分配位置**
#### 1. **对象创建方式决定内存位置**
   - **栈上对象**：  
     如果对象是局部变量（在函数内定义），则其成员变量分配在栈上。
     ```cpp
     void func() {
         MyClass obj; // obj 及其成员变量分配在栈上
     }
     ```

   - **堆上对象**：  
     如果对象通过 `new` 动态创建，则其成员变量分配在堆上。
     ```cpp
     void func() {
         MyClass* obj = new MyClass(); // obj 及其成员变量分配在堆上
         delete obj; // 必须手动释放
     }
     ```

#### 2. **成员变量类型决定内存位置**
   - **普通成员变量**：  
     分配在对象所在的内存区域（栈或堆）。
     ```cpp
     class MyClass {
     public:
         int x; // 分配在对象所在的内存区域
     };
     ```

   - **指针成员变量**：  
     指针本身分配在对象所在的内存区域，但其指向的内存可能分配在堆上。
     ```cpp
     class MyClass {
     public:
         int* ptr; // ptr 分配在对象所在的内存区域
         MyClass() : ptr(new int(42)) {} // ptr 指向的内存分配在堆上
         ~MyClass() { delete ptr; }
     };
     ```

   - **动态数组或容器**：  
     如果成员变量是动态数组或容器（如 `std::vector`），其内部数据通常分配在堆上。
     ```cpp
     class MyClass {
     public:
         std::vector<int> vec; // vec 的数据分配在堆上
     };
     ```


### **二、成员变量内存分配的示例**
#### 1. **栈上对象**
   ```cpp
   class MyClass {
   public:
       int x;
       std::string name;
   };

   void func() {
       MyClass obj; // obj 及其成员变量分配在栈上
       obj.x = 42;
       obj.name = "Stack";
   }
   ```
   - 内存布局：
     ```
     +---------+---------+
     |   x     |  name   |
     +---------+---------+
     | 4 bytes | 动态大小|
     +---------+---------+
     ```

#### 2. **堆上对象**
   ```cpp
   void func() {
       MyClass* obj = new MyClass(); // obj 及其成员变量分配在堆上
       obj->x = 42;
       obj->name = "Heap";
       delete obj; // 手动释放
   }
   ```
   - 内存布局：
     ```
     +---------+---------+
     |   x     |  name   |
     +---------+---------+
     | 4 bytes | 动态大小|
     +---------+---------+
     ```

#### 3. **指针成员变量**
   ```cpp
   class MyClass {
   public:
       int* ptr;
       MyClass() : ptr(new int(42)) {} // ptr 指向的内存分配在堆上
       ~MyClass() { delete ptr; }
   };

   void func() {
       MyClass obj; // obj 分配在栈上，ptr 指向的内存分配在堆上
   }
   ```
   - 内存布局：
     ```
     +---------+
     |   ptr   |
     +---------+
     | 8 bytes |
     +---------+
     ```

#### 4. **动态数组或容器**
   ```cpp
   class MyClass {
   public:
       std::vector<int> vec; // vec 的数据分配在堆上
   };

   void func() {
       MyClass obj; // obj 分配在栈上，vec 的数据分配在堆上
       obj.vec.push_back(42);
   }
   ```
   - 内存布局：
     ```
     +---------+
     |   vec   |
     +---------+
     | 动态大小|
     +---------+
     ```


### **三、总结**
| **成员变量类型**       | **内存分配位置**                     |
|------------------------|--------------------------------------|
| 普通成员变量           | 与对象相同（栈或堆）                 |
| 指针成员变量           | 指针本身与对象相同，指向的内存在堆上 |
| 动态数组或容器         | 容器本身与对象相同，数据在堆上       |

**核心原则**：
- 对象的内存分配位置（栈或堆）决定了其成员变量的内存位置。
- 动态分配的资源（如 `new`、`std::vector` 的数据）通常分配在堆上。
- 栈上对象的生命周期由作用域决定，堆上对象的生命周期由程序员控制。


---
## virtual 关键字的作用
在 C++ 中，`virtual` 关键字用于实现 **多态（Polymorphism）**，是面向对象编程中动态绑定的核心机制。它的核心作用是让程序在运行时（而非编译时）根据对象的实际类型调用正确的成员函数。以下是 `virtual` 关键字的详细作用和使用场景：

### **1. 实现多态**
#### **核心作用**：
- **动态绑定**：通过基类指针或引用调用虚函数时，实际调用的是对象所属派生类的重写版本。
- **打破默认的静态绑定**：若没有 `virtual`，编译器会根据指针/引用的类型（而非对象实际类型）决定调用哪个函数。

#### **示例**：
```cpp
class Animal {
public:
    virtual void speak() { // 声明为虚函数
        std::cout << "Animal sound\n";
    }
};

class Dog : public Animal {
public:
    void speak() override { // 重写基类虚函数
        std::cout << "Woof!\n";
    }
};

int main() {
    Animal* animal = new Dog();
    animal->speak(); // 输出 "Woof!"（若 speak 非虚，则输出 "Animal sound"）
    delete animal;
    return 0;
}
```


### **2. 虚析构函数**
#### **必要性**：
- 当通过基类指针删除派生类对象时，若基类析构函数非虚，**只会调用基类析构函数**，导致派生类的析构函数不被执行，引发资源泄漏。
- **规则**：若类可能被继承，且需要通过基类指针释放派生类对象，基类析构函数必须声明为 `virtual`。

#### **示例**：
```cpp
class Base {
public:
    virtual ~Base() { // 虚析构函数
        std::cout << "Base destroyed\n";
    }
};

class Derived : public Base {
public:
    ~Derived() override {
        std::cout << "Derived destroyed\n";
    }
};

int main() {
    Base* obj = new Derived();
    delete obj; // 输出：Derived destroyed → Base destroyed
    return 0;
}
```

### **3. 纯虚函数与抽象类**
#### **纯虚函数**：
- 通过 `virtual 返回类型 函数名(参数) = 0;` 声明。
- **抽象类**：包含纯虚函数的类不能实例化，必须由派生类实现所有纯虚函数。

#### **示例**：
```cpp
class Shape { // 抽象类
public:
    virtual double area() const = 0; // 纯虚函数
};

class Circle : public Shape {
private:
    double radius;
public:
    Circle(double r) : radius(r) {}
    double area() const override { // 实现纯虚函数
        return 3.14 * radius * radius;
    }
};

int main() {
    // Shape shape; // 错误：抽象类不能实例化
    Shape* shape = new Circle(5.0);
    std::cout << shape->area(); // 输出 78.5
    delete shape;
    return 0;
}
```


### **4. 虚函数表（vtable）**
#### **底层机制**：
- 每个包含虚函数的类都有一个 **虚函数表**（编译器自动生成），存储虚函数地址。
- 每个对象内部包含一个 **虚函数指针（vptr）**，指向所属类的虚函数表。
- **运行时多态**：通过 `vptr` 和 `vtable` 在运行时确定调用哪个函数。

#### **内存开销**：
- 每个对象需额外存储一个 `vptr`（通常 4/8 字节）。
- 虚函数调用比普通函数稍慢（需间接寻址）。


### **5. 使用场景**
1. **基类设计**：若需要派生类重写某些行为（如接口类）。
2. **多态需求**：通过基类指针统一管理不同派生类对象。
3. **资源安全**：确保派生类析构函数被调用（避免内存泄漏）。

### **6. 注意事项**
- **避免滥用**：虚函数会引入额外开销，非多态场景无需使用。
- **覆盖规范**：C++11 起可用 `override` 关键字显式标记重写函数，提高代码可读性：
  ```cpp
  class Derived : public Base {
  public:
      void foo() override { // 明确表示重写基类虚函数
          // ...
      }
  };
  ```
- **final 关键字**：禁止派生类重写虚函数：
  ```cpp
  class Base {
  public:
      virtual void foo() final {} // 派生类不能重写 foo
  };
  ```


### **总结**
| **场景**               | **作用**                                                                 |
|-------------------------|--------------------------------------------------------------------------|
| 普通虚函数              | 实现运行时多态，允许派生类重写行为。                                     |
| 虚析构函数              | 确保通过基类指针删除派生类对象时，派生类析构函数被调用。                 |
| 纯虚函数                | 定义接口，强制派生类实现特定功能。                                       |
| 虚函数表（vtable）      | 实现动态绑定的底层机制，支持运行时多态。                                 |

**核心价值**：`virtual` 关键字让 C++ 支持面向对象的多态特性，是构建灵活、可扩展软件的核心工具。

---
## 虚函数表
在 C++ 中，**虚函数表（Virtual Function Table，简称 vtable）** 是实现动态多态（运行时多态）的核心机制。它是编译器自动生成的一种隐藏数据结构，用于存储类的虚函数地址，使得程序能够在运行时根据对象的实际类型调用正确的函数版本。


### **1. 虚函数表的核心作用**
- **动态绑定**：通过虚函数表，程序在运行时（而非编译时）确定调用哪个虚函数。
- **支持多态**：允许基类指针或引用调用派生类重写的虚函数。
- **统一接口**：通过基类虚函数表，管理不同派生类的函数实现。


### **2. 虚函数表的结构**
- **每个包含虚函数的类** 都有自己的虚函数表。
- **表中条目**：按声明顺序存储类的虚函数地址（包括继承的虚函数）。
- **虚函数指针（vptr）**：
  - 每个对象实例内部隐式包含一个指向虚函数表的指针（`vptr`）。
  - `vptr` 在对象构造时由编译器自动初始化，指向所属类的虚函数表。

#### **示例：单继承的虚函数表**
```cpp
class Base {
public:
    virtual void func1() { /* ... */ }
    virtual void func2() { /* ... */ }
};

class Derived : public Base {
public:
    void func1() override { /* ... */ } // 重写 func1
    virtual void func3() { /* ... */ }  // 新增虚函数
};
```

**虚函数表结构**：
- **`Base` 的虚函数表**：
  ```
  [0] Base::func1 的地址
  [1] Base::func2 的地址
  ```
- **`Derived` 的虚函数表**：
  ```
  [0] Derived::func1 的地址（重写 Base::func1）
  [1] Base::func2 的地址（未重写）
  [2] Derived::func3 的地址（新增）
  ```


### **3. 虚函数表的底层工作原理**
#### **(1) 对象内存布局**
一个包含虚函数的对象，其内存布局通常如下：
```
|-----------------------|
|   vptr (指向 vtable)  |  ← 隐式成员变量
|-----------------------|
|   其他成员变量        |
|-----------------------|
```

#### **(2) 虚函数调用过程**
当通过基类指针调用虚函数时：
```cpp
Base* obj = new Derived();
obj->func1(); // 动态绑定到 Derived::func1
```
具体步骤：
1. 通过 `obj` 找到 `vptr`。
2. 通过 `vptr` 找到虚函数表。
3. 在虚函数表中查找 `func1` 的地址（索引由编译器在编译时确定）。
4. 跳转到该地址执行函数。


### **4. 虚函数表在多继承中的处理**
多继承时，每个基类可能有独立的虚函数表，派生类会合并或扩展这些表。

#### **示例：多继承**
```cpp
class Base1 {
public:
    virtual void func1() { /* ... */ }
};

class Base2 {
public:
    virtual void func2() { /* ... */ }
};

class Derived : public Base1, public Base2 {
public:
    void func1() override { /* ... */ }
    virtual void func3() { /* ... */ }
};
```

**内存布局**：
- `Derived` 对象包含两个 `vptr`（分别指向 `Base1` 和 `Base2` 的虚函数表）。
- **`Base1` 的虚函数表**：
  ```
  [0] Derived::func1 的地址（重写）
  [1] Derived::func3 的地址（新增）
  ```
- **`Base2` 的虚函数表**：
  ```
  [0] Base2::func2 的地址（未重写）
  ```

### **5. 虚函数表的开销**
- **内存开销**：
  - 每个对象需要存储 `vptr`（通常 4 或 8 字节）。
  - 每个类需要存储虚函数表（通常一份表供所有实例共享）。
- **性能开销**：
  - 虚函数调用比普通函数多一次间接寻址（访问虚函数表）。
  - 无法内联虚函数（除非编译器能确定具体类型，如 `final` 类）。


### **6. 虚函数表的实现差异**
- **编译器依赖**：虚函数表是编译器的实现细节，并非 C++ 标准强制规定。
- **常见编译器行为**：
  - GCC/Clang：虚函数表存储在只读数据段（`.rodata`）。
  - MSVC：类似，但具体布局可能不同。


### **7. 如何观察虚函数表？**
#### **(1) 通过调试器**
在调试模式下，可以查看对象的 `vptr` 和虚函数表内容（需编译器支持）。

#### **(2) 手动解析内存（示例）**
```cpp
#include <iostream>

class Base {
public:
    virtual void func() { std::cout << "Base\n"; }
};

class Derived : public Base {
public:
    void func() override { std::cout << "Derived\n"; }
};

int main() {
    Derived d;
    // 获取对象的 vptr
    void** vptr = *(void***)&d;
    // 获取 func 的地址（假设虚函数表中第一个条目）
    using FuncPtr = void(*)();
    FuncPtr func = (FuncPtr)vptr[0];
    func(); // 输出 "Derived"
    return 0;
}
```


### **8. 虚函数表的实际应用**
- **动态多态**：实现接口与实现的分离（如工厂模式、策略模式）。
- **RTTI（运行时类型识别）**：通过 `typeinfo` 实现 `typeid` 和 `dynamic_cast`。
- **调试工具**：分析对象类型和虚函数调用关系。


### **总结**
| **特性**         | **说明**                                                                 |
|------------------|--------------------------------------------------------------------------|
| **核心作用**     | 实现运行时多态，动态绑定函数调用。                                       |
| **内存布局**     | 对象包含 `vptr`，指向类的虚函数表。                                      |
| **多继承处理**   | 每个基类可能对应独立的虚函数表，派生类合并或扩展这些表。                 |
| **开销**         | 内存（每个对象一个 `vptr`）和性能（间接寻址）开销。                      |
| **编译器依赖**   | 实现细节因编译器而异，但基本逻辑一致。                                   |


---
## 什么场景下需要禁止派生类重写基类虚函数？
在 C++ 中，禁止派生类重写虚函数通常是为了 **保持基类关键逻辑的稳定性** 和 **强制遵循特定设计约束**。以下是禁止虚函数重写的核心原因和具体场景分析：


### **一、禁止重写虚函数的核心原因**
#### 1. **维护关键行为的一致性**
   - **场景**：基类定义了一个核心算法或关键操作，必须保证所有派生类严格遵循该逻辑。
   - **示例**：加密算法基类要求所有派生类使用相同的哈希计算方式。
     ```cpp
     class Encryption {
     public:
         virtual std::string hash(const std::string& data) const final { // 禁止重写
             return sha256(data); // 强制使用 SHA-256 算法
         }
     };
     ```

#### 2. **防止破坏基类不变性（Invariants）**
   - **场景**：基类的某些操作依赖内部状态或前置条件，若派生类重写虚函数可能破坏这些约束。
   - **示例**：线程安全队列的入队操作需要同步锁，若派生类重写时未加锁会导致竞态条件。
     ```cpp
     class ThreadSafeQueue {
     public:
         virtual void push(int val) final { // 禁止重写
             std::lock_guard<std::mutex> lock(mtx);
             do_push(val); // 确保锁机制不被破坏
         }
     private:
         std::mutex mtx;
         virtual void do_push(int val) = 0; // 派生类可扩展具体实现
     };
     ```

#### 3. **优化性能**
   - **场景**：虚函数调用有额外开销（查虚函数表），若函数逻辑固定，可标记为 `final` 帮助编译器去虚拟化（Devirtualization）。
   - **示例**：数学运算基类的基础方法（如归一化）。
     ```cpp
     class Vector {
     public:
         virtual void normalize() final { // 禁止重写
             // 固定归一化逻辑，允许编译器内联优化
         }
     };
     ```

#### 4. **强制接口与实现的分离**
   - **场景**：基类通过非虚接口（Non-Virtual Interface, NVI）模式将公共逻辑封装在非虚函数中，虚函数仅用于扩展细节。
   - **示例**：模板方法模式中，基类控制流程，派生类实现细节。
     ```cpp
     class DataProcessor {
     public:
         void process() final { // 禁止重写流程
             open();
             read();
             close();
         }
     private:
         virtual void open() = 0; // 派生类实现细节
         virtual void read() = 0;
         virtual void close() = 0;
     };
     ```


### **二、如何禁止虚函数重写？**
#### 1. **使用 `final` 关键字（C++11+）**
   - **语法**：在虚函数声明后添加 `final`。
     ```cpp
     class Base {
     public:
         virtual void func() final {} // 禁止派生类重写
     };
     ```

#### 2. **非虚函数设计**
   - **策略**：如果函数不需要多态行为，直接声明为非虚函数。
     ```cpp
     class Base {
     public:
         void criticalOperation() { // 非虚函数，不可重写
             // 固定逻辑
         }
     };
     ```


### **三、禁止重写的适用场景**
| **场景**                | **示例**                                                                 | **禁止方式**              |
|-------------------------|-------------------------------------------------------------------------|--------------------------|
| 加密算法核心步骤        | 所有加密派生类必须使用相同的哈希算法                                    | `final` 标记哈希函数      |
| 线程安全操作            | 派生类不得绕过基类的锁机制                                              | `final` 标记同步方法      |
| 数学运算基础逻辑        | 向量归一化必须遵循固定公式                                              | `final` 标记数学方法      |
| 模板方法模式            | 流程控制由基类固定（如 `open-read-close`），派生类仅填充细节             | `final` 标记流程控制方法  |


### **四、注意事项**
1. **谨慎使用 `final`**  
   - 过度使用会限制代码扩展性，仅在明确需要强制约束时使用。
2. **替代方案：私有虚函数**  
   - 将虚函数设为 `private`，派生类可通过覆盖私有虚函数实现扩展，但无法修改公有接口。
     ```cpp
     class Base {
     public:
         void publicMethod() { // 非虚公有接口
             privateMethod();
         }
     private:
         virtual void privateMethod() {} // 派生类可重写
     };
     ```


### **五、总结**
禁止派生类重写虚函数的核心目的是 **保护基类关键逻辑的完整性和稳定性**，适用于需要强制行为一致、防止破坏不变性、优化性能或实施设计模式的场景。通过 `final` 关键字或非虚接口设计，可以在灵活性和约束性之间找到平衡。

---
## 基类里的成员函数一定是虚函数吗
在 C++ 中，**基类的成员函数不一定是虚函数**。是否将基类成员函数声明为 `virtual`，取决于是否需要通过基类指针或引用实现 **运行时多态**。以下是详细说明：


### **1. 基类函数非虚的情况**
- **静态绑定**：若基类函数未声明为 `virtual`，则通过基类指针或引用调用该函数时，**始终调用基类的版本**（即使对象实际是派生类）。
- **适用场景**：当不需要派生类重写该函数，或明确希望强制使用基类实现时。

#### **示例**：
```cpp
class Base {
public:
    void show() { // 非虚函数
        std::cout << "Base::show()\n";
    }
};

class Derived : public Base {
public:
    void show() { // 隐藏基类的 show()
        std::cout << "Derived::show()\n";
    }
};

int main() {
    Base* obj = new Derived();
    obj->show(); // 输出 "Base::show()"（非虚函数，静态绑定）
    delete obj;
    return 0;
}
```


### **2. 基类函数为虚的情况**
- **动态绑定**：若基类函数声明为 `virtual`，则通过基类指针或引用调用该函数时，**根据对象实际类型调用派生类的重写版本**。
- **适用场景**：需要实现多态行为，允许派生类自定义函数逻辑。

#### **示例**：
```cpp
class Base {
public:
    virtual void show() { // 虚函数
        std::cout << "Base::show()\n";
    }
};

class Derived : public Base {
public:
    void show() override { // 重写基类虚函数
        std::cout << "Derived::show()\n";
    }
};

int main() {
    Base* obj = new Derived();
    obj->show(); // 输出 "Derived::show()"（虚函数，动态绑定）
    delete obj;
    return 0;
}
```


### **3. 必须使用虚函数的情况**
#### **(1) 实现多态**
若要通过基类指针/引用调用派生类的函数，基类函数必须声明为 `virtual`。

#### **(2) 虚析构函数**
若通过基类指针删除派生类对象，基类析构函数必须为虚函数，否则派生类的析构函数不会被调用，导致资源泄漏：
```cpp
class Base {
public:
    virtual ~Base() { // 虚析构函数
        std::cout << "Base destroyed\n";
    }
};

class Derived : public Base {
public:
    ~Derived() override {
        std::cout << "Derived destroyed\n";
    }
};

int main() {
    Base* obj = new Derived();
    delete obj; // 输出：Derived destroyed → Base destroyed
    return 0;
}
```


### **4. 基类函数是否应为虚函数？**
| **场景**                     | **是否声明为虚函数**          | **原因**                                                                 |
|------------------------------|-----------------------------|-------------------------------------------------------------------------|
| 需要派生类重写并实现多态       | ✅ 声明为 `virtual`          | 实现动态绑定，根据对象类型调用正确函数。                                 |
| 基类提供默认实现，允许派生类覆盖 | ✅ 声明为 `virtual`          | 派生类可选择重写或直接使用基类实现。                                     |
| 基类函数为通用工具方法         | ❌ 无需声明为 `virtual`      | 无需多态，直接使用基类实现即可。                                         |
| 基类析构函数                  | ✅ 必须声明为 `virtual`      | 确保通过基类指针删除派生类对象时，派生类析构函数被调用。                 |


### **5. 虚函数的开销**
- **内存开销**：每个对象需存储一个虚函数表指针（`vptr`），通常 4/8 字节。
- **性能开销**：虚函数调用需通过虚函数表间接寻址，略慢于普通函数。
- **设计原则**：仅在需要多态时使用虚函数，避免滥用。


### **总结**
- **基类成员函数不一定是虚函数**，是否声明为 `virtual` 取决于是否需要多态。
- **必须为虚函数的情况**：
  - 需要派生类重写并实现运行时多态。
  - 基类析构函数（若可能通过基类指针删除派生类对象）。
- **非虚函数的优势**：减少内存和性能开销，适用于无需多态的场景。

---
## vector vs deque
在C++标准模板库（STL）中，`deque`（双端队列，全称double-ended queue）是一种支持高效在头部和尾部插入、删除元素的顺序容器，同时提供随机访问能力。以下是关于`deque`的详细介绍：


### **一、`deque`的核心特性**
1. **双端操作高效**  
   - 在头部（`push_front`/`pop_front`）和尾部（`push_back`/`pop_back`）插入/删除元素的时间复杂度为 **O(1)**。
   - 相比`vector`（尾部操作O(1)，头部操作O(n)），`deque`在两端操作更高效。

2. **随机访问支持**  
   - 支持通过下标（`operator[]`）或迭代器直接访问元素，时间复杂度为 **O(1)**（实际性能可能略低于`vector`）。

3. **非连续内存布局**  
   - `deque`由多个固定大小的内存块（缓冲区）组成，通过中控器（指针数组）管理块之间的逻辑连续性。
   - 内存分配按需扩展，无需整体重新分配（与`vector`不同）。


### **二、`deque`的内部实现**
#### 1. **分段连续存储**
   - `deque`内部由多个等长的内存块（如512字节）链接而成，每个块存储若干元素。
   - 中控器（`map`）是一个动态数组，保存指向各个内存块的指针。
   - 示例结构：
     ```
     map: [ptr1, ptr2, ptr3, ...]  
                |       |       |
                v       v       v  
              Block1  Block2  Block3
     ```

#### 2. **迭代器设计**
   - 迭代器需记录当前元素所在块、块内位置及中控器信息，以支持跨块遍历。
   - 示例（伪代码）：
     ```cpp
     struct deque_iterator {
         T* current;          // 当前元素指针
         T* block_start;      // 当前块起始地址
         T* block_end;        // 当前块结束地址
         size_t block_index;  // 当前块在中控器的索引
     };
     ```

#### 3. **扩容机制**
   - 当一端的内存块已满时，分配新块并更新中控器。
   - 扩容无需移动现有元素，效率高于`vector`的整体拷贝。


### **三、`deque`的操作与复杂度**
| **操作**               | **时间复杂度** | **说明**                          |
|------------------------|----------------|-----------------------------------|
| `push_front()`/`pop_front()` | O(1) | 头部插入/删除                     |
| `push_back()`/`pop_back()`   | O(1) | 尾部插入/删除                     |
| `operator[]`/`at()`          | O(1) | 随机访问（需计算块和偏移）        |
| `insert()`/`erase()`         | O(n) | 中间插入/删除（需移动元素）       |
| `size()`                     | O(1) | 返回元素总数                      |
| `empty()`                    | O(1) | 判断是否为空                      |


### **四、`deque`的代码示例**
#### 1. **基本操作**
```cpp
#include <deque>
#include <iostream>

int main() {
    std::deque<int> dq = {1, 2, 3};

    // 头部插入
    dq.push_front(0);    // dq: [0, 1, 2, 3]

    // 尾部插入
    dq.push_back(4);     // dq: [0, 1, 2, 3, 4]

    // 随机访问
    std::cout << dq[2];  // 输出: 2

    // 头部删除
    dq.pop_front();      // dq: [1, 2, 3, 4]

    // 遍历
    for (int num : dq) {
        std::cout << num << " ";  // 输出: 1 2 3 4
    }
}
```

#### 2. **与`vector`的性能对比**
```cpp
// 头部插入耗时测试（deque更快）
std::deque<int> dq;
std::vector<int> vec;

// 插入10万个元素到头部
for (int i = 0; i < 100000; ++i) {
    dq.push_front(i);   // O(1)
    vec.insert(vec.begin(), i); // O(n) - 性能差
}
```


### **五、`deque`的适用场景**
1. **高频双端操作**  
   - 如实现队列（FIFO）或双端队列（Deque）数据结构。
   - 示例：BFS算法中的待处理节点队列。

2. **避免`vector`的扩容开销**  
   - 当元素数量未知且需频繁两端插入时，`deque`的内存分配更高效。

3. **随机访问需求**  
   - 需要下标访问且对中间插入不敏感的场景。


### **六、`deque`的局限性**
1. **中间操作效率低**  
   - `insert()`/`erase()`在中间位置的时间复杂度为O(n)，不适用于频繁中间修改的场景。

2. **内存碎片**  
   - 分段存储可能导致内存碎片，影响缓存局部性。

3. **迭代器失效规则复杂**  
   - 在中间插入/删除时，部分迭代器、指针和引用可能失效。


### **七、与其他容器的对比**
| **容器**    | **优势**                          | **劣势**                          |
|-------------|-----------------------------------|-----------------------------------|
| `vector`    | 内存连续，随机访问极快            | 头部插入/删除效率低               |
| `list`      | 任意位置插入/删除O(1)，无失效问题 | 不支持随机访问，内存开销大        |
| `deque`     | 双端操作高效，支持随机访问        | 中间操作慢，内存非连续            |


### **八、总结**
- **使用场景优先**：在需要频繁双端操作且需随机访问时，优先选择`deque`。
- **性能权衡**：虽然随机访问稍慢于`vector`，但双端操作优势明显。
- **内存管理**：分段存储减少扩容开销，但可能影响缓存效率。


---

## vector vs array
**`std::vector`** 和 **`std::array`** 是 C++ 标准库中两种常用的容器，分别用于动态数组和固定大小数组。以下是它们的详细对比：


### **一、基本概念**
#### 1. **`std::vector`**
- **功能**：动态数组，支持自动扩容。
- **适用场景**：需要动态调整大小的数组。

#### 2. **`std::array`**
- **功能**：固定大小数组，大小在编译时确定。
- **适用场景**：需要固定大小的数组。


### **二、核心区别**
| **特性**               | **`std::vector`**                    | **`std::array`**                    |
|------------------------|----------------------------------------|-------------------------------------|
| **大小**               | 动态调整                               | 固定大小                            |
| **内存管理**           | 自动管理                               | 手动管理                            |
| **性能**               | 动态扩容有开销                         | 性能更高                            |
| **适用场景**           | 需要动态调整大小的场景                 | 需要固定大小的场景                  |
| **C++ 标准**           | C++98                                  | C++11                              |
| **常用操作**           | `push_back()`、`pop_back()`、`resize()`| `fill()`、`size()`                  |


### **三、详细对比**
#### 1. **大小**
- **`std::vector`**：
  - 大小可以动态调整。
  - 示例：
    ```cpp
    std::vector<int> vec = {1, 2, 3};
    vec.push_back(4); // 大小变为 4
    ```

- **`std::array`**：
  - 大小在编译时确定，无法动态调整。
  - 示例：
    ```cpp
    std::array<int, 3> arr = {1, 2, 3};
    // arr.size() 始终为 3
    ```

#### 2. **内存管理**
- **`std::vector`**：
  - 自动管理内存，支持动态扩容。
  - 示例：
    ```cpp
    std::vector<int> vec;
    vec.reserve(100); // 预分配内存
    ```

- **`std::array`**：
  - 内存由程序员手动管理。
  - 示例：
    ```cpp
    std::array<int, 100> arr; // 固定大小
    ```

#### 3. **性能**
- **`std::vector`**：
  - 动态扩容时可能涉及内存重新分配和数据拷贝。
  - 示例：
    ```cpp
    std::vector<int> vec;
    for (int i = 0; i < 100000; ++i) {
        vec.push_back(i); // 可能触发多次扩容
    }
    ```

- **`std::array`**：
  - 性能更高，无需动态扩容。
  - 示例：
    ```cpp
    std::array<int, 100000> arr;
    for (int i = 0; i < 100000; ++i) {
        arr[i] = i; // 无需扩容
    }
    ```

#### 4. **适用场景**
- **`std::vector`**：
  - 需要动态调整大小的场景。
  - 示例：存储用户输入、动态生成的数据。

- **`std::array`**：
  - 需要固定大小的场景。
  - 示例：存储固定大小的数据集合（如矩阵、缓冲区）。

#### 5. **C++ 标准**
- **`std::vector`**：
  - 从 C++98 开始支持。
- **`std::array`**：
  - 从 C++11 开始支持。


### **四、示例代码**
#### 1. **`std::vector` 示例**
```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3};
    vec.push_back(4); // 动态扩容
    for (int i : vec) {
        std::cout << i << " ";
    }
    return 0;
}
```

#### 2. **`std::array` 示例**
```cpp
#include <iostream>
#include <array>

int main() {
    std::array<int, 3> arr = {1, 2, 3};
    for (int i : arr) {
        std::cout << i << " ";
    }
    return 0;
}
```


### **五、总结**
- **`std::vector`**：
  - 动态数组，支持自动扩容。
  - 适用于需要动态调整大小的场景。
- **`std::array`**：
  - 固定大小数组，性能更高。
  - 适用于需要固定大小的场景。

--- 
## vector\list\deque\queue
在C++标准模板库（STL）中，`vector`、`list`、`deque`和`queue`是常用的容器，它们在数据结构、操作效率和适用场景上有显著差异。以下是它们的详细对比：


### **1. 数据结构与内存布局**
| 容器         | 数据结构                  | 内存布局                          | 特点                                                                 |
|--------------|---------------------------|-----------------------------------|----------------------------------------------------------------------|
| **`vector`** | 动态数组                  | 连续内存块                        | 支持快速随机访问；尾部插入/删除高效，中间操作需移动元素。             |
| **`list`**   | 双向链表                  | 非连续，每个节点含前后指针        | 任意位置插入/删除高效；不支持随机访问；内存开销大（指针占空间）。     |
| **`deque`**  | 双端队列（分段连续数组）  | 多块连续内存块组成的链表          | 头尾插入/删除高效；支持随机访问（效率略低于`vector`）。              |
| **`queue`**  | 容器适配器（默认`deque`） | 依赖底层容器（如`deque`或`list`） | 先进先出（FIFO），仅允许在尾部插入、头部删除；不支持随机访问/遍历。   |


### **2. 时间复杂度对比**
| 操作               | `vector`        | `list`          | `deque`         | `queue`（适配器） |
|--------------------|-----------------|-----------------|-----------------|-------------------|
| **随机访问**       | O(1)            | O(n)            | O(1)            | 不支持            |
| **头部插入/删除**  | O(n)            | O(1)            | O(1)            | O(1)（仅删除）    |
| **尾部插入/删除**  | O(1)（均摊）    | O(1)            | O(1)            | O(1)（仅插入）    |
| **中间插入/删除**  | O(n)            | O(1)            | O(n)            | 不支持            |
| **内存分配**       | 动态扩容（复制）| 按需分配节点    | 分块扩容        | 依赖底层容器      |


### **3. 核心特性与适用场景**
#### **`vector`**
- **优点**：
  - 内存连续，缓存友好，随机访问速度快。
  - 尾部操作高效（均摊O(1)）。
- **缺点**：
  - 中间/头部插入删除效率低（需移动元素）。
  - 扩容时可能复制全部元素，性能开销大。
- **适用场景**：
  - 需要频繁随机访问（如数组遍历）。
  - 尾部频繁插入/删除（如栈结构）。

#### **`list`**
- **优点**：
  - 任意位置插入/删除高效（O(1)）。
  - 迭代器稳定性高（插入删除不失效）。
- **缺点**：
  - 不支持随机访问，查找效率低（O(n)）。
  - 内存碎片化，额外指针占用空间。
- **适用场景**：
  - 频繁在任意位置插入/删除（如链表操作）。
  - 需要稳定迭代器的场景。

#### **`deque`**
- **优点**：
  - 头尾插入/删除高效（O(1)）。
  - 支持随机访问（效率接近`vector`）。
  - 扩容时分块分配，避免大规模复制。
- **缺点**：
  - 中间插入/删除效率低（O(n)）。
  - 随机访问需计算内存块，略慢于`vector`。
- **适用场景**：
  - 需要高效头尾操作且偶尔随机访问（如队列+栈混合需求）。

#### **`queue`**
- **优点**：
  - 严格遵循FIFO，接口简洁（`push`、`pop`、`front`、`back`）。
  - 默认基于`deque`，头尾操作高效。
- **缺点**：
  - 功能受限，不支持遍历或中间操作。
  - 性能依赖底层容器（如改用`list`则内存开销增大）。
- **适用场景**：
  - 需要先进先出逻辑（如任务调度、消息队列）。


### **4. 迭代器与内存管理**
| 特性               | `vector`                | `list`                  | `deque`                 | `queue`                |
|--------------------|-------------------------|-------------------------|-------------------------|------------------------|
| **迭代器类型**     | 随机访问迭代器          | 双向迭代器              | 随机访问迭代器          | 不支持迭代器           |
| **插入/删除影响**  | 可能导致所有迭代器失效  | 仅影响被操作节点的迭代器| 可能导致部分迭代器失效  | 依赖底层容器           |
| **内存连续性**     | 连续                    | 非连续                  | 分段连续                | 依赖底层容器           |


### **5. 代码示例**
#### **`vector`：动态数组**
```cpp
#include <vector>
std::vector<int> vec;
vec.push_back(10);          // 尾部插入：O(1)
vec.insert(vec.begin(), 5); // 头部插入：O(n)
int x = vec[2];             // 随机访问：O(1)
```

#### **`list`：双向链表**
```cpp
#include <list>
std::list<int> lst;
lst.push_back(10);          // 尾部插入：O(1)
lst.push_front(5);          // 头部插入：O(1)
auto it = lst.begin();
std::advance(it, 2);        // 遍历到第3个元素：O(n)
lst.insert(it, 7);          // 中间插入：O(1)
```

#### **`deque`：双端队列**
```cpp
#include <deque>
std::deque<int> dq;
dq.push_back(10);           // 尾部插入：O(1)
dq.push_front(5);           // 头部插入：O(1)
int y = dq[1];              // 随机访问：O(1)
```

#### **`queue`：队列适配器**
```cpp
#include <queue>
std::queue<int> q;
q.push(10);                 // 尾部插入：O(1)
q.pop();                    // 头部删除：O(1)
int front = q.front();      // 访问头部：O(1)
```


### **6. 总结**
| **容器**   | **核心优势**                  | **典型场景**                     |
|------------|-------------------------------|----------------------------------|
| `vector`   | 快速随机访问，尾部高效        | 动态数组、栈、需要连续内存的操作 |
| `list`     | 任意位置插入/删除，迭代器稳定 | 链表、频繁中间操作               |
| `deque`    | 高效头尾操作+随机访问         | 双端队列、队列与栈的混合需求     |
| `queue`    | 严格FIFO逻辑                  | 任务队列、消息缓冲               |

**选择建议**：
- 需要随机访问且尾部操作频繁 → **`vector`**。
- 频繁在任意位置插入/删除 → **`list`**。
- 高效头尾操作且偶尔随机访问 → **`deque`**。
- 简单FIFO需求 → **`queue`**（适配器）。

---
## list
在 C++ 标准模板库（STL）中，`std::list` 是一个基于 **双向链表** 实现的容器，它允许高效的插入和删除操作，但不支持随机访问。以下是关于 `std::list` 的详细介绍：


### **1. 基本特性**
- **数据结构**：双向链表，每个节点包含数据值和指向前后节点的指针。
- **内存布局**：非连续内存，节点分散在堆中。
- **迭代器类型**：双向迭代器（支持 `++` 和 `--`，但不支持随机跳跃）。
- **时间复杂度**：
  - 任意位置插入/删除：**O(1)**（已知迭代器位置）。
  - 随机访问：**O(n)**（需遍历链表）。
- **内存开销**：每个节点需要额外存储两个指针（前驱和后继）。


### **2. 核心操作**
#### **(1) 构造函数**
```cpp
#include <list>

// 默认构造
std::list<int> list1;

// 构造含 n 个元素的列表，默认值为 0
std::list<int> list2(5);       // {0, 0, 0, 0, 0}

// 构造含 n 个元素的列表，值为 val
std::list<int> list3(5, 42);   // {42, 42, 42, 42, 42}

// 通过迭代器构造
std::vector<int> vec = {1, 2, 3};
std::list<int> list4(vec.begin(), vec.end());  // {1, 2, 3}

// 拷贝构造
std::list<int> list5(list4);   // {1, 2, 3}
```

#### **(2) 插入元素**
- **`push_back(val)`**：尾部插入元素（O(1)）。
- **`push_front(val)`**：头部插入元素（O(1)）。
- **`insert(iterator, val)`**：在指定迭代器位置前插入元素（O(1)）。
- **`emplace_back(args...)`**：尾部直接构造元素（C++11，避免拷贝）。
- **`emplace_front(args...)`**：头部直接构造元素（C++11）。

```cpp
std::list<int> lst = {1, 2, 3};

lst.push_back(4);      // {1, 2, 3, 4}
lst.push_front(0);     // {0, 1, 2, 3, 4}

auto it = lst.begin();
std::advance(it, 3);   // 移动迭代器到第4个位置
lst.insert(it, 99);    // {0, 1, 2, 99, 3, 4}

lst.emplace_back(5);   // {0, 1, 2, 99, 3, 4, 5}
```

#### **(3) 删除元素**
- **`pop_back()`**：删除尾部元素（O(1)）。
- **`pop_front()`**：删除头部元素（O(1)）。
- **`erase(iterator)`**：删除指定迭代器位置的元素（O(1)）。
- **`remove(val)`**：删除所有等于 `val` 的元素（O(n)）。
- **`clear()`**：清空链表（O(n)）。

```cpp
std::list<int> lst = {0, 1, 2, 2, 3, 2, 4};

lst.pop_back();        // {0, 1, 2, 2, 3, 2}
lst.pop_front();       // {1, 2, 2, 3, 2}

auto it = lst.begin();
std::advance(it, 2);   // 移动到第3个元素
lst.erase(it);         // {1, 2, 3, 2}

lst.remove(2);         // 删除所有2 → {1, 3}
lst.clear();           // 清空链表
```

#### **(4) 访问元素**
- **`front()`**：返回头部元素（O(1)）。
- **`back()`**：返回尾部元素（O(1)）。
- **不支持 `operator[]` 和 `at()`**（无法随机访问）。

```cpp
std::list<int> lst = {10, 20, 30};
int first = lst.front();  // 10
int last = lst.back();    // 30
```


### **3. 迭代器稳定性**
- **插入操作**：插入元素不会使其他元素的迭代器失效。
- **删除操作**：只有被删除元素的迭代器失效，其他迭代器仍有效。
- **与 `vector`/`deque` 对比**：`vector` 在扩容时所有迭代器失效，`deque` 在中间插入时部分失效。

### **4. 算法与成员函数**
#### **(1) 排序**
- **`sort()`**：成员函数，对链表进行排序（时间复杂度 **O(n log n)**）。
- 与 `std::sort` 的区别：`std::sort` 需要随机访问迭代器，因此不能用于 `list`。

```cpp
std::list<int> lst = {3, 1, 4, 1, 5};
lst.sort();  // {1, 1, 3, 4, 5}
```

#### **(2) 合并**
- **`merge(other_list)`**：合并两个已排序的链表（目标链表必须已排序）。

```cpp
std::list<int> lst1 = {1, 3, 5};
std::list<int> lst2 = {2, 4, 6};
lst1.merge(lst2);  // lst1 → {1, 2, 3, 4, 5, 6}, lst2 为空
```

#### **(3) 去重**
- **`unique()`**：删除相邻重复元素（通常需先排序）。

```cpp
std::list<int> lst = {1, 2, 2, 3, 3, 3};
lst.unique();      // {1, 2, 3}
```

#### **(4) 拼接**
- **`splice(iterator, other_list)`**：将 `other_list` 的元素移动到当前链表的指定位置。

```cpp
std::list<int> lst1 = {1, 2, 3};
std::list<int> lst2 = {4, 5, 6};

auto it = lst1.begin();
std::advance(it, 1);           // 移动到第2个位置
lst1.splice(it, lst2);         // lst1 → {1, 4, 5, 6, 2, 3}, lst2 为空
```


### **5. 优缺点分析**
#### **优点**：
1. **任意位置高效插入/删除**（已知迭代器位置）。
2. **迭代器稳定性高**（插入/删除操作不影响其他迭代器）。
3. **内存按需分配**（无预分配或扩容开销）。

#### **缺点**：
1. **不支持随机访问**（访问第 n 个元素需遍历）。
2. **内存开销大**（每个节点存储两个指针）。
3. **缓存不友好**（非连续内存，访问局部性差）。


### **6. 适用场景**
- **频繁在任意位置插入/删除元素**：如实现 LRU 缓存、事件调度器。
- **需要稳定迭代器**：在遍历过程中可能修改链表结构。
- **内存分配灵活**：无需预知元素数量，避免 `vector` 扩容开销。


### **7. 示例代码**
#### **实现 LRU 缓存**
```cpp
#include <list>
#include <unordered_map>

template <typename K, typename V>
class LRUCache {
private:
    using Pair = std::pair<K, V>;
    std::list<Pair> cache;
    std::unordered_map<K, typename std::list<Pair>::iterator> map;
    size_t capacity;

public:
    LRUCache(size_t cap) : capacity(cap) {}

    V get(K key) {
        auto it = map.find(key);
        if (it == map.end()) return V(); // 未找到
        cache.splice(cache.begin(), cache, it->second); // 移动到头部
        return it->second->second;
    }

    void put(K key, V value) {
        auto it = map.find(key);
        if (it != map.end()) {
            it->second->second = value;
            cache.splice(cache.begin(), cache, it->second); // 移动到头部
            return;
        }
        if (cache.size() >= capacity) {
            auto last = cache.back().first;
            map.erase(last);
            cache.pop_back();
        }
        cache.emplace_front(key, value);
        map[key] = cache.begin();
    }
};
```


### **总结**
`std::list` 是 C++ 中基于双向链表的容器，适合需要高效插入/删除和迭代器稳定性的场景。尽管它在随机访问和缓存友好性上表现较差，但在特定问题（如 LRU 缓存、事件驱动编程）中具有不可替代的优势。

--- 
## string
`std::string` 是 C++ 标准库中用于表示和操作字符串的类，它封装了字符数组，提供了丰富的字符串操作功能。以下是关于 `std::string` 的详细介绍：


### **一、基本特性**
1. **动态字符串**：
   - `std::string` 是一个动态数组，可以自动调整大小。
   - 支持高效的字符串操作（如拼接、查找、替换）。

2. **内存管理**：
   - 自动管理内存，无需手动分配和释放。

3. **兼容性**：
   - 可以与 C 风格字符串（`char*`）互相转换。


### **二、常用操作**
#### 1. **构造和初始化**
- 默认构造：
  ```cpp
  std::string str;
  ```
- 使用 C 风格字符串初始化：
  ```cpp
  std::string str = "Hello";
  ```
- 使用字符初始化：
  ```cpp
  std::string str(5, 'A'); // "AAAAA"
  ```

#### 2. **访问元素**
- 使用下标访问：
  ```cpp
  char ch = str[0];
  ```
- 使用 `at()` 访问（带边界检查）：
  ```cpp
  char ch = str.at(0);
  ```

#### 3. **修改字符串**
- 拼接字符串：
  ```cpp
  str += " World";
  str.append("!");
  ```
- 插入字符：
  ```cpp
  str.insert(5, " C++");
  ```
- 删除字符：
  ```cpp
  str.erase(5, 4); // 从位置 5 开始删除 4 个字符
  ```

#### 4. **查找和替换**
- 查找子串：
  ```cpp
  size_t pos = str.find("World");
  ```
- 替换子串：
  ```cpp
  str.replace(6, 5, "Universe"); // 将 "World" 替换为 "Universe"
  ```

#### 5. **大小和容量**
- 获取字符串长度：
  ```cpp
  size_t len = str.size(); // 或 str.length()
  ```
- 检查是否为空：
  ```cpp
  bool isEmpty = str.empty();
  ```
- 调整大小：
  ```cpp
  str.resize(10); // 调整字符串大小为 10
  ```

#### 6. **比较字符串**
- 使用 `==`、`!=`、`<`、`>` 等运算符：
  ```cpp
  if (str1 == str2) {
      std::cout << "Strings are equal" << std::endl;
  }
  ```

#### 7. **转换**
- 转换为 C 风格字符串：
  ```cpp
  const char* cstr = str.c_str();
  ```
- 转换为数值：
  ```cpp
  int num = std::stoi("123");
  double d = std::stod("3.14");
  ```


### **三、示例代码**
```cpp
#include <iostream>
#include <string>

int main() {
    // 构造和初始化
    std::string str = "Hello";
    std::cout << "Initial string: " << str << std::endl;

    // 拼接字符串
    str += " World";
    std::cout << "After concatenation: " << str << std::endl;

    // 插入字符
    str.insert(5, " C++");
    std::cout << "After insertion: " << str << std::endl;

    // 查找子串
    size_t pos = str.find("World");
    if (pos != std::string::npos) {
        std::cout << "'World' found at position: " << pos << std::endl;
    }

    // 替换子串
    str.replace(6, 5, "Universe");
    std::cout << "After replacement: " << str << std::endl;

    // 转换为 C 风格字符串
    const char* cstr = str.c_str();
    std::cout << "C-style string: " << cstr << std::endl;

    return 0;
}
```


### **四、性能优化**
1. **预分配内存**：
   - 使用 `reserve()` 预分配内存，避免频繁扩容。
   ```cpp
   std::string str;
   str.reserve(100); // 预分配 100 字节
   ```

2. **避免不必要的拷贝**：
   - 使用引用或移动语义传递 `std::string`。
   ```cpp
   void processString(const std::string& str); // 使用引用
   ```

3. **使用 `std::string_view`（C++17）**：
   - 避免拷贝，适用于只读字符串操作。
   ```cpp
   std::string_view view = "Hello";
   ```


### **五、总结**
- `std::string` 是 C++ 中用于表示和操作字符串的类，支持动态调整大小和丰富的操作。
- 提供了高效的字符串操作功能，如拼接、查找、替换等。
- 通过预分配内存和使用引用，可以进一步优化性能。

--- 
## sizeof
在 C++11 中，`sizeof` 是一个运算符，用于计算数据类型或对象的大小（以字节为单位）。它是编译时计算的，返回一个 `size_t` 类型的值。`sizeof` 的使用方式在 C++11 中与之前的 C++ 标准基本相同，但 C++11 引入了一些新的特性（如 `decltype` 和 `alignof`），可以与 `sizeof` 结合使用。

### 1. `sizeof` 的基本用法
`sizeof` 可以用于以下两种形式：
1. **计算类型的大小**：
   ```cpp
   sizeof(type)
   ```
2. **计算表达式或对象的大小**：
   ```cpp
   sizeof(expression)
   ```

#### 示例：
```cpp
#include <iostream>

int main() {
    int a = 10;
    std::cout << "Size of int: " << sizeof(int) << std::endl;          // 输出 int 类型的大小
    std::cout << "Size of a: " << sizeof(a) << std::endl;              // 输出变量 a 的大小
    std::cout << "Size of expression: " << sizeof(a + 1.5) << std::endl; // 输出表达式 a + 1.5 的大小
    return 0;
}
```

#### 输出：
```
Size of int: 4
Size of a: 4
Size of expression: 8
```

### 2. `sizeof` 与 C++11 新特性
C++11 引入了一些新特性，可以与 `sizeof` 结合使用。

#### （1）`sizeof` 与 `decltype`
`decltype` 用于推导表达式的类型，可以与 `sizeof` 结合使用来计算类型的大小。

##### 示例：
```cpp
#include <iostream>

int main() {
    int a = 10;
    double b = 3.14;
    std::cout << "Size of decltype(a + b): " << sizeof(decltype(a + b)) << std::endl;
    return 0;
}
```

##### 输出：
```
Size of decltype(a + b): 8
```

#### （2）`sizeof` 与 `alignof`
`alignof` 用于获取类型的对齐要求（alignment），可以与 `sizeof` 结合使用来了解类型的大小和对齐。

##### 示例：
```cpp
#include <iostream>

struct alignas(16) AlignedStruct {
    int a;
    double b;
};

int main() {
    std::cout << "Size of AlignedStruct: " << sizeof(AlignedStruct) << std::endl;
    std::cout << "Alignment of AlignedStruct: " << alignof(AlignedStruct) << std::endl;
    return 0;
}
```

##### 输出：
```
Size of AlignedStruct: 16
Alignment of AlignedStruct: 16
```

### 3. `sizeof` 的特殊用法
#### （1）计算数组的大小
`sizeof` 可以用于计算整个数组的大小。

##### 示例：
```cpp
#include <iostream>

int main() {
    int arr[10];
    std::cout << "Size of array: " << sizeof(arr) << std::endl; // 输出数组的总大小
    std::cout << "Number of elements: " << sizeof(arr) / sizeof(arr[0]) << std::endl; // 输出数组的元素个数
    return 0;
}
```

##### 输出：
```
Size of array: 40
Number of elements: 10
```

#### （2）计算结构体的大小
`sizeof` 可以用于计算结构体的大小，注意结构体可能存在填充（padding）以对齐成员。

##### 示例：
```cpp
#include <iostream>

struct MyStruct {
    char a;
    int b;
    double c;
};

int main() {
    std::cout << "Size of MyStruct: " << sizeof(MyStruct) << std::endl;
    return 0;
}
```

##### 输出：
```
Size of MyStruct: 16
```

### 4. `sizeof` 的注意事项
1. **编译时计算**：`sizeof` 是编译时计算的，不会对表达式进行求值。
   ```cpp
   int a = 10;
   std::cout << sizeof(a++); // a++ 不会被执行
   std::cout << a;           // 输出 10
   ```

2. **指针的大小**：`sizeof` 计算指针时，返回的是指针本身的大小，而不是指向对象的大小。
   ```cpp
   int* ptr;
   std::cout << sizeof(ptr); // 输出指针的大小（通常为 8 字节，64 位系统）
   ```

3. **动态分配的内存**：`sizeof` 不能用于计算动态分配的内存大小。
   ```cpp
   int* arr = new int[10];
   std::cout << sizeof(arr); // 输出指针的大小，而不是数组的大小
   ```

### 5. 总结
- `sizeof` 是 C++ 中用于计算类型或对象大小的运算符。
- 在 C++11 中，`sizeof` 可以与 `decltype` 和 `alignof` 结合使用。
- `sizeof` 是编译时计算的，不会对表达式求值。
- 常用于计算数组大小、结构体大小以及类型的大小。
---
## sizeof（void）
在 C++ 中，`sizeof(void)` 是一个不合法的操作，会导致编译错误。这是因为 `void` 是一个不完整的类型（incomplete type），它没有大小（size），编译器无法计算其大小。

### 1. 为什么 `sizeof(void)` 不合法？
- `void` 是一个特殊的类型，表示“无类型”或“空类型”。
- 它通常用于以下场景：
  - 函数的返回类型（表示函数不返回任何值）。
  - 函数的参数列表（表示函数不接受任何参数）。
  - 通用指针类型（`void*`，可以指向任何类型的数据）。
- 由于 `void` 不表示任何具体的值或对象，因此它没有大小。

### 2. 示例代码
如果尝试编译以下代码，编译器会报错：
```cpp
#include <iostream>

int main() {
    std::cout << sizeof(void) << std::endl; // 错误：非法操作
    return 0;
}
```

#### 编译器错误：
```
error: invalid application of 'sizeof' to a void type
```


### 3. `sizeof(void*)` 是合法的
虽然 `sizeof(void)` 不合法，但 `sizeof(void*)` 是合法的。`void*` 是一个指向 `void` 的指针，指针的大小是固定的，与指向的类型无关。

#### 示例：
```cpp
#include <iostream>

int main() {
    std::cout << "Size of void*: " << sizeof(void*) << std::endl;
    return 0;
}
```

#### 输出：
```
Size of void*: 8  // 在 64 位系统上，指针的大小通常为 8 字节
```


### 4. 总结
- `sizeof(void)` 是不合法的操作，因为 `void` 是一个不完整的类型，没有大小。
- `sizeof(void*)` 是合法的，因为它计算的是指针的大小，而不是 `void` 的大小。
- 如果需要表示“无类型”或“空类型”，应使用 `void` 的指针形式（`void*`）。
---
## 前置自增
前置自增（`++i`）是 C++ 中的一种运算符，用于将变量的值加 1，并返回自增后的值。与后置自增（`i++`）不同，前置自增的效率通常更高，因为它不需要保存自增前的值。


### 1. 语法
```cpp
++i;
```
- `i` 是要自增的变量。
- 表达式的结果是自增后的值。


### 2. 行为
- 先将变量的值加 1。
- 然后返回自增后的值。

#### 示例：
```cpp
int i = 5;
int j = ++i; // i 先自增为 6，然后 j 被赋值为 6
std::cout << i << ", " << j; // 输出: 6, 6
```


### 3. 与后置自增的区别
- **前置自增（`++i`）**：
  - 先自增，后返回值。
  - 效率较高，因为不需要保存自增前的值。
- **后置自增（`i++`）**：
  - 先返回当前值，后自增。
  - 效率较低，因为需要保存自增前的值。

#### 示例对比：
```cpp
int i = 5;
int j = i++; // j 被赋值为 5，然后 i 自增为 6
std::cout << i << ", " << j; // 输出: 6, 5
```


### 4. 性能分析
- **前置自增**：
  - 直接对变量进行自增操作，并返回自增后的值。
  - 不需要额外的临时变量。
- **后置自增**：
  - 需要保存自增前的值，然后自增，最后返回保存的值。
  - 可能会引入额外的开销。

在循环或性能敏感的代码中，优先使用前置自增。

### 5. 适用场景
- **前置自增**：
  - 循环中的迭代器自增。
  - 需要直接使用自增后的值。
- **后置自增**：
  - 需要先使用当前值，再自增。

#### 示例：循环中使用前置自增
```cpp
for (int i = 0; i < 10; ++i) {
    std::cout << i << " "; // 输出: 0 1 2 3 4 5 6 7 8 9
}
```

### 6. 自定义类型中的前置自增
对于自定义类型（如类或结构体），可以通过重载 `operator++` 来实现前置自增。

#### 示例：
```cpp
class Counter {
public:
    int value;

    Counter(int v = 0) : value(v) {}

    // 前置自增
    Counter& operator++() {
        ++value;
        return *this;
    }

    // 后置自增
    Counter operator++(int) {
        Counter temp = *this;
        ++value;
        return temp;
    }
};

int main() {
    Counter c(5);
    ++c; // 前置自增
    std::cout << c.value; // 输出: 6

    Counter d = c++; // 后置自增
    std::cout << c.value << ", " << d.value; // 输出: 7, 6
    return 0;
}
```


### 7. 总结
- 前置自增（`++i`）先自增，后返回值，效率较高。
- 后置自增（`i++`）先返回值，后自增，效率较低。
- 在循环或性能敏感的代码中，优先使用前置自增。
- 对于自定义类型，可以通过重载 `operator++` 实现前置自增和后置自增。
---
## 单例模式
**单例模式（Singleton Pattern）** 是一种设计模式，用于确保一个类只有一个实例，并提供一个全局访问点。以下是 C++ 中实现单例模式的几种常见方式：


### **一、经典实现（非线程安全）**
#### 1. **实现代码**
```cpp
class Singleton {
public:
    // 获取单例实例
    static Singleton& getInstance() {
        static Singleton instance; // 局部静态变量
        return instance;
    }

    // 删除拷贝构造函数和赋值运算符
    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;

private:
    // 私有构造函数
    Singleton() {}
};
```

#### 2. **使用示例**
```cpp
int main() {
    Singleton& instance = Singleton::getInstance();
    return 0;
}
```

#### 3. **特点**
- **优点**：简单易用。
- **缺点**：非线程安全（C++11 之前）。


### **二、线程安全实现（C++11）**
#### 1. **实现代码**
```cpp
#include <mutex>

class Singleton {
public:
    // 获取单例实例
    static Singleton& getInstance() {
        static Singleton instance; // C++11 保证局部静态变量的线程安全
        return instance;
    }

    // 删除拷贝构造函数和赋值运算符
    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;

private:
    // 私有构造函数
    Singleton() {}
};
```

#### 2. **使用示例**
```cpp
int main() {
    Singleton& instance = Singleton::getInstance();
    return 0;
}
```

#### 3. **特点**
- **优点**：线程安全，简单高效。
- **缺点**：依赖 C++11 标准。


### **三、双重检查锁定（Double-Checked Locking）**
#### 1. **实现代码**
```cpp
#include <mutex>

class Singleton {
public:
    // 获取单例实例
    static Singleton* getInstance() {
        if (instance == nullptr) { // 第一次检查
            std::lock_guard<std::mutex> lock(mutex); // 加锁
            if (instance == nullptr) { // 第二次检查
                instance = new Singleton();
            }
        }
        return instance;
    }

    // 删除拷贝构造函数和赋值运算符
    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;

private:
    // 私有构造函数
    Singleton() {}

    // 静态成员变量
    static Singleton* instance;
    static std::mutex mutex;
};

// 初始化静态成员变量
Singleton* Singleton::instance = nullptr;
std::mutex Singleton::mutex;
```

#### 2. **使用示例**
```cpp
int main() {
    Singleton* instance = Singleton::getInstance();
    return 0;
}
```

#### 3. **特点**
- **优点**：线程安全，性能较高（仅在第一次创建实例时加锁）。
- **缺点**：实现复杂，容易出错。


### **四、Meyer's Singleton（推荐）**
#### 1. **实现代码**
```cpp
class Singleton {
public:
    // 获取单例实例
    static Singleton& getInstance() {
        static Singleton instance; // C++11 保证局部静态变量的线程安全
        return instance;
    }

    // 删除拷贝构造函数和赋值运算符
    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;

private:
    // 私有构造函数
    Singleton() {}
};
```

#### 2. **使用示例**
```cpp
int main() {
    Singleton& instance = Singleton::getInstance();
    return 0;
}
```

#### 3. **特点**
- **优点**：线程安全，简单高效。
- **缺点**：依赖 C++11 标准。


### **五、总结**
- **经典实现**：简单但非线程安全。
- **线程安全实现**：C++11 标准下推荐使用。
- **双重检查锁定**：性能较高但实现复杂。
- **Meyer's Singleton**：C++11 标准下最佳选择。

--- 
## LRU
_C++实现一个缓存，用LRU淘汰机制，支持TTL过期，同时要并发安全_
实现一个支持 **LRU 淘汰机制** 和 **TTL 过期** 的并发安全缓存，可以使用以下设计：


### **设计思路**
1. **数据结构**：
   - 使用 `std::unordered_map` 存储键值对，实现 O(1) 的查找。
   - 使用 `std::list` 实现 LRU 链表，记录访问顺序。
   - 使用 `std::mutex` 保证并发安全。

2. **LRU 淘汰机制**：
   - 每次访问（读或写）时，将节点移动到链表头部。
   - 当缓存达到容量上限时，淘汰链表尾部的节点。

3. **TTL 过期机制**：
   - 每个缓存项记录插入时间。
   - 在访问时检查是否过期，过期则删除。

4. **并发安全**：
   - 使用 `std::mutex` 或 `std::shared_mutex` 保护共享资源。


### **代码实现**

```cpp
#include <iostream>
#include <unordered_map>
#include <list>
#include <mutex>
#include <chrono>
#include <thread>
#include <memory>

class LRUCache {
public:
    using KeyType = std::string;
    using ValueType = std::string;
    using TimePoint = std::chrono::steady_clock::time_point;

    struct CacheItem {
        ValueType value;
        TimePoint timestamp;
    };

    LRUCache(size_t capacity, size_t ttlSeconds)
        : capacity_(capacity), ttlSeconds_(ttlSeconds) {}

    // 获取缓存值
    std::optional<ValueType> get(const KeyType& key) {
        std::unique_lock<std::mutex> lock(mutex_);
        auto it = cacheMap_.find(key);
        if (it == cacheMap_.end()) {
            return std::nullopt; // 未找到
        }

        // 检查是否过期
        if (isExpired(it->second.timestamp)) {
            cacheList_.erase(it->second.listIt);
            cacheMap_.erase(it);
            return std::nullopt; // 已过期
        }

        // 更新访问时间并移动到链表头部
        cacheList_.splice(cacheList_.begin(), cacheList_, it->second.listIt);
        return it->second.value;
    }

    // 插入或更新缓存值
    void put(const KeyType& key, const ValueType& value) {
        std::unique_lock<std::mutex> lock(mutex_);
        auto it = cacheMap_.find(key);

        // 如果键已存在，更新值并移动到链表头部
        if (it != cacheMap_.end()) {
            it->second.value = value;
            it->second.timestamp = getCurrentTime();
            cacheList_.splice(cacheList_.begin(), cacheList_, it->second.listIt);
            return;
        }

        // 如果缓存已满，淘汰最久未使用的项
        if (cacheMap_.size() >= capacity_) {
            auto last = cacheList_.back();
            cacheMap_.erase(last);
            cacheList_.pop_back();
        }

        // 插入新项
        cacheList_.push_front(key);
        cacheMap_[key] = {value, getCurrentTime(), cacheList_.begin()};
    }

    // 删除缓存项
    void remove(const KeyType& key) {
        std::unique_lock<std::mutex> lock(mutex_);
        auto it = cacheMap_.find(key);
        if (it != cacheMap_.end()) {
            cacheList_.erase(it->second.listIt);
            cacheMap_.erase(it);
        }
    }

    // 清空缓存
    void clear() {
        std::unique_lock<std::mutex> lock(mutex_);
        cacheMap_.clear();
        cacheList_.clear();
    }

private:
    // 检查是否过期
    bool isExpired(const TimePoint& timestamp) const {
        auto now = getCurrentTime();
        return std::chrono::duration_cast<std::chrono::seconds>(now - timestamp).count() >= ttlSeconds_;
    }

    // 获取当前时间
    TimePoint getCurrentTime() const {
        return std::chrono::steady_clock::now();
    }

    size_t capacity_; // 缓存容量
    size_t ttlSeconds_; // TTL 过期时间（秒）
    std::mutex mutex_; // 互斥锁

    // 缓存数据结构
    std::list<KeyType> cacheList_; // LRU 链表
    std::unordered_map<KeyType, std::pair<CacheItem, typename std::list<KeyType>::iterator>> cacheMap_;
};

int main() {
    LRUCache cache(2, 5); // 容量为 2，TTL 为 5 秒

    cache.put("key1", "value1");
    cache.put("key2", "value2");

    if (auto value = cache.get("key1")) {
        std::cout << "key1: " << *value << std::endl;
    } else {
        std::cout << "key1 not found or expired" << std::endl;
    }

    std::this_thread::sleep_for(std::chrono::seconds(6)); // 等待 6 秒

    if (auto value = cache.get("key1")) {
        std::cout << "key1: " << *value << std::endl;
    } else {
        std::cout << "key1 not found or expired" << std::endl;
    }

    return 0;
}
```

### **代码说明**
1. **数据结构**：
   - `cacheList_`：双向链表，记录访问顺序。
   - `cacheMap_`：哈希表，存储键值对和链表迭代器。

2. **LRU 淘汰机制**：
   - 每次访问时，将节点移动到链表头部。
   - 当缓存满时，淘汰链表尾部的节点。

3. **TTL 过期机制**：
   - 每个缓存项记录插入时间。
   - 在访问时检查是否过期，过期则删除。

4. **并发安全**：
   - 使用 `std::mutex` 保护共享资源。


### **测试与优化**
1. **测试**：
   - 测试并发访问（多线程读写）。
   - 测试 LRU 淘汰和 TTL 过期逻辑。

2. **优化**：
   - 使用 `std::shared_mutex` 实现读写锁，提高读性能。
   - 使用定时器定期清理过期缓存项。


### **总结**
- 该实现支持 LRU 淘汰和 TTL 过期，同时保证并发安全。
- 适用于高并发场景下的缓存需求，如 Web 服务器、数据库查询缓存等。

--- 
## 检测内存泄漏的工具
在 C++ 中，内存泄漏是一个常见问题，通常是由于动态分配的内存未正确释放导致的。为了检测和修复内存泄漏，可以使用多种工具和技术。以下是一些常用的内存泄漏检测工具：


### 一、工具分类
#### 1. **静态分析工具**
- 在编译时或代码编写阶段分析代码，检测潜在的内存泄漏问题。
- 优点：无需运行程序，适合早期发现问题。
- 缺点：可能产生误报或漏报。

#### 2. **动态分析工具**
- 在程序运行时检测内存泄漏。
- 优点：准确率高，能定位具体泄漏点。
- 缺点：需要运行程序，可能影响性能。


### 二、常用工具
#### 1. **Valgrind**
- **平台**：Linux。
- **功能**：
  - 检测内存泄漏、非法内存访问、未初始化内存使用等问题。
  - 提供详细的调用栈信息，帮助定位问题。
- **使用方法**：
  ```bash
  valgrind --leak-check=full ./your_program
  ```
- **输出示例**：
  ```
  ==12345== HEAP SUMMARY:
  ==12345==     in use at exit: 72 bytes in 3 blocks
  ==12345==   total heap usage: 10 allocs, 7 frees, 1,024 bytes allocated
  ==12345==
  ==12345== LEAK SUMMARY:
  ==12345==    definitely lost: 24 bytes in 1 blocks
  ==12345==    indirectly lost: 48 bytes in 2 blocks
  ==12345==      possibly lost: 0 bytes in 0 blocks
  ==12345==    still reachable: 0 bytes in 0 blocks
  ==12345==         suppressed: 0 bytes in 0 blocks
  ```

#### 2. **AddressSanitizer (ASan)**
- **平台**：Linux、macOS、Windows（部分支持）。
- **功能**：
  - 检测内存泄漏、缓冲区溢出、使用释放后的内存等问题。
  - 性能开销较低，适合生产环境。
- **使用方法**：
  - 编译时添加 `-fsanitize=address` 选项：
    ```bash
    g++ -fsanitize=address -g -o your_program your_program.cpp
    ./your_program
    ```
- **输出示例**：
  ```
  =================================================================
  ==12345==ERROR: LeakSanitizer: detected memory leaks

  Direct leak of 24 byte(s) in 1 object(s) allocated from:
      #0 0x4f5b2d in malloc (/path/to/your_program+0x4f5b2d)
      #1 0x4006b6 in main /path/to/your_program.cpp:10
  ```

#### 3. **Dr. Memory**
- **平台**：Windows、Linux。
- **功能**：
  - 检测内存泄漏、非法内存访问、未初始化内存使用等问题。
  - 支持多线程程序。
- **使用方法**：
  ```bash
  drmemory -- ./your_program
  ```

#### 4. **Visual Studio 内存分析工具**
- **平台**：Windows。
- **功能**：
  - 集成在 Visual Studio 中，提供内存使用情况和泄漏检测。
  - 支持调试模式和性能分析。
- **使用方法**：
  1. 在 Visual Studio 中打开项目。
  2. 选择 **Debug > Windows > Memory Usage**。
  3. 运行程序并查看内存使用情况。

#### 5. **LeakSanitizer (LSan)**
- **平台**：Linux、macOS。
- **功能**：
  - 专注于检测内存泄漏。
  - 与 AddressSanitizer 集成，性能开销低。
- **使用方法**：
  - 编译时添加 `-fsanitize=leak` 选项：
    ```bash
    g++ -fsanitize=leak -g -o your_program your_program.cpp
    ./your_program
    ```

#### 6. **Electric Fence**
- **平台**：Linux。
- **功能**：
  - 检测内存越界访问和释放后的内存使用。
  - 通过库链接方式使用。
- **使用方法**：
  ```bash
  g++ -g -o your_program your_program.cpp -lefence
  ./your_program
  ```

#### 7. **Cppcheck**
- **平台**：跨平台。
- **功能**：
  - 静态代码分析工具，检测内存泄漏、未初始化变量等问题。
  - 无需运行程序。
- **使用方法**：
  ```bash
  cppcheck --enable=all your_program.cpp
  ```


### 三、选择工具的建议
1. **开发阶段**：
   - 使用 **静态分析工具**（如 Cppcheck）在早期发现问题。
   - 使用 **动态分析工具**（如 Valgrind、AddressSanitizer）在运行时检测问题。

2. **生产环境**：
   - 使用 **AddressSanitizer** 或 **LeakSanitizer**，性能开销较低。

3. **平台支持**：
   - **Linux**：Valgrind、AddressSanitizer、LeakSanitizer。
   - **Windows**：Visual Studio 内存分析工具、Dr. Memory。
   - **跨平台**：Cppcheck。


### 四、预防内存泄漏的最佳实践
1. **使用智能指针**：
   - 使用 `std::unique_ptr` 或 `std::shared_ptr` 自动管理内存。
   ```cpp
   std::unique_ptr<int> ptr = std::make_unique<int>(42);
   ```

2. **遵循 RAII 原则**：
   - 资源获取即初始化（RAII），确保资源在对象生命周期结束时自动释放。

3. **避免裸指针**：
   - 尽量避免使用裸指针（`int*`），使用智能指针或容器（如 `std::vector`）。

4. **定期检查**：
   - 在开发过程中定期使用工具检测内存泄漏。


### 五、总结
- **Valgrind** 和 **AddressSanitizer** 是最常用的内存泄漏检测工具。
- **智能指针** 和 **RAII** 是预防内存泄漏的最佳实践。
- 根据开发阶段和平台选择合适的工具，可以有效检测和修复内存泄漏问题。

---
## 什么是泛型编程
泛型编程（Generic Programming）是一种编程范式，允许开发者编写与**数据类型无关**的代码，从而提高代码的复用性、类型安全性和可维护性。它的核心思想是**将算法与数据类型解耦**，使得同一段代码可以适用于多种不同的数据类型，而无需为每种类型重复编写逻辑。
  

### **为什么需要泛型编程？**
在没有泛型的情况下，开发者通常需要为不同的数据类型编写重复的代码。例如：
- 实现一个通用的“数组排序”函数，需要为 `int[]`、`string[]` 等不同类型各写一个版本。
- 创建容器（如列表、字典）时，若想支持多种数据类型，可能需要使用 `void*`（C语言）或 `interface{}`（Go语言早期），但这会牺牲类型安全性。

**泛型的核心价值**：通过**类型参数化**，让代码逻辑与具体类型无关，同时保持类型安全。


### **泛型编程的实现方式**
不同语言对泛型的支持方式不同，以下是几种典型实现：

#### 1. **C++ 的模板（Templates）**
- **原理**：通过编译器生成具体类型的代码（编译时多态）。
- **示例**：
  ```cpp
  template <typename T>
  T max(T a, T b) {
      return (a > b) ? a : b;
  }
  ```
  - 调用 `max(3, 5)` 或 `max(3.14, 2.71)` 时，编译器会生成 `int` 或 `double` 版本的函数。
- **特点**：
  - 高度灵活，支持类型推导和元编程。
  - 可能导致代码膨胀（每个类型生成一份代码）。

#### 2. **Java 的泛型（Generics）**
- **原理**：通过类型擦除（Type Erasure）在编译后保留类型信息，运行时实际为 `Object` 类型。
- **示例**：
  ```java
  public class Box<T> {
      private T value;
      public void set(T value) { this.value = value; }
      public T get() { return value; }
  }
  ```
  - 调用 `Box<Integer> box = new Box<>();` 时，编译器会检查类型安全，但运行时 `T` 被擦除为 `Object`。
- **特点**：
  - 类型安全，但无法支持原始类型（需装箱）。
  - 运行时无法获取泛型类型信息。

#### 3. **Go 的泛型（1.18+ 版本）**
- **原理**：通过类型参数和类型约束实现，编译时生成代码。
- **示例**：
  ```go
  func Max[T constraints.Ordered](a, b T) T {
      if a > b {
          return a
      }
      return b
  }
  ```
  - 调用 `Max(3, 5)` 或 `Max(3.14, 2.71)` 时，编译器会生成具体类型的函数。
- **特点**：
  - 简洁明确，强调代码可读性。
  - 不支持运算符重载，需通过接口约束类型行为。

#### 4. **Rust 的泛型**
- **原理**：通过编译时单态化（Monomorphization）生成具体类型的代码。
- **示例**：
  ```rust
  fn max<T: PartialOrd>(a: T, b: T) -> T {
      if a > b { a } else { b }
  }
  ```
  - 调用 `max(3, 5)` 或 `max(3.14, 2.71)` 时，编译器会生成 `i32` 或 `f64` 版本的函数。
- **特点**：
  - 零运行时开销，类型安全。
  - 支持特质（Trait）约束类型行为。


### **泛型编程的优势**
1. **代码复用**：同一逻辑可应用于多种类型，减少重复代码。
2. **类型安全**：编译器在编译期检查类型合法性，避免运行时错误。
3. **性能优化**：在 C++ 和 Rust 中，泛型代码编译后与手动编写的类型特定代码性能一致。
4. **抽象能力**：通过类型约束（如 Go 的接口、Rust 的 Trait）定义类型的行为，增强代码的抽象性。


### **泛型编程的典型应用场景**
1. **容器类**：如列表（`List<T>`）、字典（`Dictionary<K, V>`）。
2. **算法库**：如排序（`sort<T>`）、查找（`find<T>`）。
3. **函数式编程工具**：如 `map`、`filter`、`reduce` 等高阶函数。
4. **数学计算**：如向量运算、矩阵操作，支持 `int`、`float` 等多种数值类型。
5. **API 设计**：提供灵活且类型安全的接口，例如数据库查询的泛型封装。


### **泛型编程的挑战**
1. **编译复杂性**：某些语言（如 C++）的模板可能导致编译时间增加。
2. **代码膨胀**：生成多个类型特化版本的代码可能增大二进制体积。
3. **学习成本**：类型约束、接口设计需要深入理解语言特性。
4. **语言支持差异**：不同语言的泛型实现差异较大（如 Java 的类型擦除 vs C++ 的模板）。


### **总结**
泛型编程通过将数据类型参数化，实现了代码逻辑与类型的解耦。它的核心价值是**提高代码的复用性和类型安全性**，同时允许开发者在不同语言中以不同的方式平衡灵活性与性能。无论是 C++ 的模板、Java 的泛型，还是 Go 和 Rust 的现代实现，泛型都是构建高效、健壮软件的重要工具。

**何时使用泛型？**
- 当需要为多种类型编写相同逻辑时。
- 当容器或算法需要类型安全性时。
- 当希望代码更具抽象性和扩展性时。

---
## C++ stl标准库
C++ 标准模板库（STL，Standard Template Library）是 C++ 标准库的核心组成部分，提供了一套丰富的通用数据结构和算法，旨在提高开发效率和代码复用性。STL 的核心思想是**泛型编程**，通过模板实现与数据类型无关的通用组件。


### **一、STL 的六大核心组件**
1. **容器（Containers）**  
   用于存储和管理数据的类模板，分为顺序容器和关联容器。
2. **算法（Algorithms）**  
   提供一系列操作容器的函数模板（如排序、查找、遍历）。
3. **迭代器（Iterators）**  
   提供访问容器元素的通用接口，是容器与算法之间的桥梁。
4. **函数对象（Function Objects）**  
   重载了 `operator()` 的类，用于自定义算法行为。
5. **适配器（Adapters）**  
   对容器或函数对象的封装（如栈、队列、优先队列）。
6. **分配器（Allocators）**  
   管理容器内存分配的低级工具，通常无需直接使用。


### **二、容器（Containers）**
#### 1. **顺序容器**
   - **`std::vector`**：动态数组，支持快速随机访问。
     ```cpp
     std::vector<int> vec = {1, 2, 3};
     vec.push_back(4); // 添加元素
     ```
   - **`std::list`**：双向链表，支持高效插入/删除。
     ```cpp
     std::list<int> lst = {1, 2, 3};
     lst.push_front(0); // 在头部插入
     ```
   - **`std::deque`**：双端队列，支持高效头尾操作。
     ```cpp
     std::deque<int> dq = {1, 2, 3};
     dq.push_back(4); // 尾部插入
     ```

#### 2. **关联容器**
   - **`std::set`**：有序集合，元素唯一。
     ```cpp
     std::set<int> s = {3, 1, 2};
     s.insert(4); // 插入元素
     ```
   - **`std::map`**：键值对集合，按键排序。
     ```cpp
     std::map<std::string, int> m = {{"Alice", 25}, {"Bob", 30}};
     m["Charlie"] = 28; // 插入键值对
     ```
   - **`std::unordered_set`** 和 **`std::unordered_map`**：基于哈希表的无序容器。

#### 3. **容器适配器**
   - **`std::stack`**：后进先出（LIFO）栈。
     ```cpp
     std::stack<int> stk;
     stk.push(1); // 压栈
     stk.pop();   // 弹栈
     ```
   - **`std::queue`**：先进先出（FIFO）队列。
   - **`std::priority_queue`**：优先队列（默认最大堆）。
     ```cpp
     std::priority_queue<int> pq;
     pq.push(3); pq.push(1); pq.push(2);
     pq.top(); // 返回最大值 3
     ```


### **三、算法（Algorithms）**
STL 提供了大量通用算法，适用于多种容器：
1. **排序与查找**
   ```cpp
   std::vector<int> vec = {3, 1, 4, 1, 5, 9};
   std::sort(vec.begin(), vec.end()); // 排序
   auto it = std::find(vec.begin(), vec.end(), 4); // 查找
   ```
2. **遍历与操作**
   ```cpp
   std::for_each(vec.begin(), vec.end(), [](int x) {
       std::cout << x << " "; // 输出每个元素
   });
   ```
3. **数值计算**
   ```cpp
   int sum = std::accumulate(vec.begin(), vec.end(), 0); // 求和
   ```


### **四、迭代器（Iterators）**
迭代器是访问容器元素的通用接口，分为以下类型：
1. **输入迭代器**：只读，单向（如 `std::istream_iterator`）。
2. **输出迭代器**：只写，单向（如 `std::ostream_iterator`）。
3. **前向迭代器**：可读写，单向（如 `std::forward_list` 的迭代器）。
4. **双向迭代器**：可读写，双向移动（如 `std::list` 的迭代器）。
5. **随机访问迭代器**：支持随机访问（如 `std::vector` 的迭代器）。

示例：
```cpp
std::vector<int> vec = {1, 2, 3};
for (auto it = vec.begin(); it != vec.end(); ++it) {
    std::cout << *it << " "; // 输出：1 2 3
}
```


### **五、函数对象（Function Objects）**
函数对象是重载了 `operator()` 的类，可用于自定义算法行为：
```cpp
struct Greater {
    bool operator()(int a, int b) const {
        return a > b;
    }
};

std::vector<int> vec = {3, 1, 4};
std::sort(vec.begin(), vec.end(), Greater()); // 降序排序
```


### **六、适配器（Adapters）**
适配器是对容器或函数对象的封装，提供特定接口：
1. **栈适配器**
   ```cpp
   std::stack<int, std::vector<int>> stk; // 基于 vector 的栈
   stk.push(1); stk.push(2);
   stk.top(); // 返回 2
   ```
2. **优先队列适配器**
   ```cpp
   std::priority_queue<int, std::vector<int>, std::greater<int>> pq; // 最小堆
   pq.push(3); pq.push(1);
   pq.top(); // 返回 1
   ```


### **七、分配器（Allocators）**
分配器用于管理容器的内存分配，通常无需直接使用：
```cpp
std::vector<int, std::allocator<int>> vec; // 默认分配器
```


### **八、STL 的优势**
1. **泛型编程**：通过模板实现与数据类型无关的通用组件。
2. **高效性**：经过高度优化的数据结构和算法。
3. **可扩展性**：支持自定义容器、迭代器和函数对象。
4. **标准化**：跨平台兼容，代码可移植性强。


### **九、STL 的局限性**
1. **学习曲线**：模板语法复杂，初学者可能难以掌握。
2. **调试困难**：模板错误信息冗长，不易排查。
3. **性能开销**：某些操作（如 `std::list` 的插入）可能不如手写代码高效。