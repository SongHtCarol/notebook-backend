# 排序

- [排序](#排序)
    - [比较类排序](#比较类排序)
      - [交换](#交换)
        - [冒泡排序](#冒泡排序)
        - [快速排序](#快速排序)
      - [插入](#插入)
        - [插入排序](#插入排序)
        - [希尔排序](#希尔排序)
      - [选择](#选择)
        - [选择排序](#选择排序)
        - [堆排序](#堆排序)
      - [归并](#归并)
        - [二路归并排序](#二路归并排序)
        - [多路归并排序](#多路归并排序)
    - [非比较类排序](#非比较类排序)
      - [计数排序](#计数排序)
      - [桶排序](#桶排序)
      - [基数排序](#基数排序)


---
### 比较类排序

#### 交换

##### 冒泡排序
从后向前，逐渐冒泡
时间复杂度：O(n^2)
稳定

##### 快速排序
选择base，将其他元素分为两部分，然后递归处理
时间复杂度：O(nlogn)
不稳定

#### 插入
##### 插入排序
将每个元素插入到已经有序的子序列中
时间复杂度：O(n^2)
稳定

##### 希尔排序
每隔k个元素进行插入排序，直到k减为1

#### 选择
##### 选择排序
在未排序的子序列里找到最小/大的元素，放在下一个位置
时间复杂度：O(n^2)
稳定

##### 堆排序
将未排序的序列构建成大根堆（根>左 根>右），每次取根放在头部（交换当前的根和当前最后的子节点），然后将交换后的堆重新调整
时间复杂度：O(nlogn)
不稳定

#### 归并
##### 二路归并排序
默认已经有两个子序列有序，对其进行合并。 处理问题的最小规模是合并两个长度小于1的子序列，停止处理的条件是两个子序列长度都为0；
时间复杂度：O(nlogn)
稳定

##### 多路归并排序
每次合并多个子序列

### 非比较类排序

#### 计数排序
非负整数序列，找出序列最大值，用一个长度为（最大值+1）的数组作为计数器，遍历待排序序列，对出现的数字计数，然后遍历计数器
时间复杂度：O(n+k)
稳定（？）

#### 桶排序
将序列分布在连续的不同的桶内，每个桶的大小固定。 对于每个数值，进行hash后放在对应的桶内，要求序号大的桶，里面的值也大。
hash参考： (val-min)/size // 将这列数值的总区间长度按size等长折叠，每一折叠是一个桶 桶个数= (max-min)/size +1
时间复杂度：O(n+k)


#### 基数排序
根据最大值的位数，从个位开始对序列安排进长度为10的桶内，安排一次拿出一次，最后为有序
时间复杂度：O(n+k)
稳定
