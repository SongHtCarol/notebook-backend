# 快表

- [快表](#快表)
  - [快表（QuickList）](#快表quicklist)
    - [一、QuickList 的设计原理](#一quicklist-的设计原理)
      - [1. **核心结构**](#1-核心结构)
      - [2. **设计目标**](#2-设计目标)
    - [二、QuickList 的优势](#二quicklist-的优势)
      - [1. **内存利用率高**](#1-内存利用率高)
      - [2. **操作性能优异**](#2-操作性能优异)
      - [3. **灵活的配置**](#3-灵活的配置)
    - [三、QuickList 的适用场景](#三quicklist-的适用场景)
    - [四、QuickList 与 ZipList 的对比](#四quicklist-与-ziplist-的对比)
    - [五、配置示例](#五配置示例)
    - [六、总结](#六总结)
  - [QuickList vs ZipList](#quicklist-vs-ziplist)
    - [1. **ZipList（压缩列表）**](#1-ziplist压缩列表)
      - [（1）**定义**](#1定义)
      - [（2）**结构**](#2结构)
      - [（3）**特点**](#3特点)
      - [（4）**适用场景**](#4适用场景)
    - [2. **QuickList（快速列表）**](#2-quicklist快速列表)
      - [（1）**定义**](#1定义-1)
      - [（2）**结构**](#2结构-1)
      - [（3）**特点**](#3特点-1)
      - [（4）**适用场景**](#4适用场景-1)
    - [3. **QuickList 和 ZipList 的对比**](#3-quicklist-和-ziplist-的对比)
    - [4. **QuickList 的配置参数**](#4-quicklist-的配置参数)
      - [示例配置：](#示例配置)
    - [5. **总结**](#5-总结)

---
## 快表（QuickList）
Redis 中的 **快表（QuickList）** 是用于实现列表（List）数据结构的一种高效存储结构，自 Redis 3.2 版本引入。它结合了 **压缩列表（ZipList）** 和 **双向链表** 的优势，在内存使用和操作性能之间取得了平衡，特别适合存储大规模列表数据。


### 一、QuickList 的设计原理
#### 1. **核心结构**
QuickList 是一个由多个 **ZipList 节点** 组成的 **双向链表**。每个 ZipList 节点是一个连续的内存块，存储多个列表元素。例如：
```
QuickList
├── ZipList 节点1 → [元素1, 元素2, 元素3]
├── ZipList 节点2 → [元素4, 元素5]
└── ZipList 节点3 → [元素6, 元素7, 元素8]
```
- **双向链表**：支持快速的前后遍历和节点插入/删除。
- **ZipList 节点**：每个节点内部使用 ZipList 存储元素，减少内存碎片。

#### 2. **设计目标**
- **内存高效**：通过 ZipList 紧凑存储元素，减少指针和元数据开销。
- **性能优化**：插入/删除操作只需在单个 ZipList 内进行，降低时间复杂度。
- **动态调整**：根据数据量和元素大小自动调整每个 ZipList 节点的容量。


### 二、QuickList 的优势
#### 1. **内存利用率高**
- **ZipList 的紧凑性**：每个 ZipList 节点存储多个元素，无需为每个元素单独分配内存和存储指针。
- **减少内存碎片**：连续内存块存储，避免频繁内存分配导致碎片。

#### 2. **操作性能优异**
- **插入/删除**：在单个 ZipList 节点内操作，时间复杂度接近 \(O(1)\)（若节点未满）。
- **遍历**：通过双向链表快速定位到目标 ZipList 节点，再在节点内遍历。

#### 3. **灵活的配置**
Redis 提供参数动态调整 QuickList 的行为：
- **`list-max-ziplist-size`**：控制每个 ZipList 节点的容量。
  - 示例：`list-max-ziplist-size -2` 表示每个 ZipList 节点最大占用 8KB。
- **`list-compress-depth`**：控制节点压缩（节省内存）。
  - 示例：`list-compress-depth 1` 表示压缩链表两端的一个节点。


### 三、QuickList 的适用场景
1. **大规模列表存储**  
   适合存储数万甚至百万级的元素，例如消息队列、用户行为日志等。

2. **元素大小适中**  
   单个元素不宜过大（例如不超过 1KB），避免 ZipList 节点膨胀。

3. **高频插入/删除**  
   若元素在列表两端操作（如 `LPUSH`/`RPOP`），QuickList 性能接近 \(O(1)\)。


### 四、QuickList 与 ZipList 的对比
| 特性                | ZipList                          | QuickList                       |
|---------------------|----------------------------------|---------------------------------|
| **数据结构**        | 单个连续内存块                  | 双向链表 + 多个 ZipList 节点    |
| **内存碎片**        | 无                              | 极少（节点内部连续）            |
| **插入性能**        | \(O(n)\)，需移动元素            | 接近 \(O(1)\)（节点未满时）     |
| **适用数据量**      | 小规模（数百元素内）            | 大规模（数万级以上）            |
| **配置灵活性**      | 固定大小                        | 动态调整节点容量和压缩策略      |


### 五、配置示例
```ini
# Redis 配置文件（redis.conf）

# 每个 ZipList 节点最多占用 8KB
list-max-ziplist-size -2

# 压缩两端的一个节点（节省内存）
list-compress-depth 1
```


### 六、总结
- **QuickList 是 Redis 列表的默认实现**，结合了 ZipList 和双向链表的优势。
- **内存高效**：通过 ZipList 紧凑存储，减少碎片。
- **性能优异**：插入/删除操作在单个 ZipList 节点内完成，接近 \(O(1)\)。
- **适用大规模数据**：通过动态调整节点容量和压缩策略，适应不同场景需求。

## QuickList vs ZipList
Redis 中的 **QuickList** 和 **ZipList** 是两种用于实现列表（List）数据结构的内存优化结构。它们的设计目标是在内存使用和性能之间找到平衡，特别是在存储大量小元素时。以下是它们的详细解析和对比：


### 1. **ZipList（压缩列表）**
#### （1）**定义**
- ZipList 是一种紧凑的、连续内存存储的数据结构，用于存储小规模的列表或哈希表。
- 它通过将多个元素紧凑地存储在一块连续的内存中，减少了内存碎片和指针开销。

#### （2）**结构**
- ZipList 的内存布局如下：
  ```
  | zlbytes | zltail | zllen | entry1 | entry2 | ... | entryN | zlend |
  ```
  - **zlbytes**：整个 ZipList 占用的字节数。
  - **zltail**：最后一个节点的偏移量。
  - **zllen**：节点数量。
  - **entryX**：每个节点，包含前一个节点的长度、当前节点的编码和数据。
  - **zlend**：结束标记（固定值 `0xFF`）。

#### （3）**特点**
- **内存紧凑**：减少了指针和元数据的开销。
- **适合小数据**：当列表元素较少且元素较小时，ZipList 非常高效。
- **性能局限**：
  - 插入和删除操作需要移动后续元素，时间复杂度为 \(O(n)\)。
  - 查找操作需要遍历，时间复杂度为 \(O(n)\)。

#### （4）**适用场景**
- 存储小规模的列表或哈希表。
- 元素较少且元素大小较小的场景。


### 2. **QuickList（快速列表）**
#### （1）**定义**
- QuickList 是 Redis 3.2 引入的一种列表实现，结合了 ZipList 和双向链表的优点。
- 它是一个由多个 ZipList 节点组成的双向链表。

#### （2）**结构**
- QuickList 的结构如下：
  ```
  QuickList
  |--> ZipList Node 1
  |--> ZipList Node 2
  |--> ...
  |--> ZipList Node N
  ```
  - 每个节点是一个 ZipList。
  - 节点之间通过双向链表连接。

#### （3）**特点**
- **内存高效**：每个节点是一个 ZipList，减少了内存碎片。
- **性能优化**：
  - 插入和删除操作只需在单个 ZipList 内进行，时间复杂度为 \(O(n)\)，但由于 ZipList 较小，实际性能接近 \(O(1)\)。
  - 查找操作可以通过双向链表快速定位到目标 ZipList，再在 ZipList 内遍历。
- **动态调整**：QuickList 可以根据元素数量和大小动态调整每个 ZipList 的大小。

#### （4）**适用场景**
- 存储大规模的列表。
- 元素数量较多或元素大小较大的场景。


### 3. **QuickList 和 ZipList 的对比**

| 特性                | ZipList                          | QuickList                       |
|---------------------|----------------------------------|---------------------------------|
| **数据结构**        | 连续内存块                      | 双向链表 + ZipList 节点         |
| **内存使用**        | 紧凑，无指针开销                | 较紧凑，有少量指针开销          |
| **插入/删除性能**   | \(O(n)\)，需要移动元素          | \(O(n)\)，但实际性能接近 \(O(1)\) |
| **查找性能**        | \(O(n)\)，需要遍历              | \(O(n)\)，但通过链表快速定位    |
| **适用场景**        | 小规模列表或哈希表              | 大规模列表                      |
| **动态调整**        | 不支持                          | 支持动态调整 ZipList 大小       |


### 4. **QuickList 的配置参数**
Redis 提供了以下参数来配置 QuickList 的行为：
- **`list-max-ziplist-size`**：控制每个 ZipList 节点的大小。
  - 正值：表示每个 ZipList 最多包含的元素个数。
  - 负值：表示每个 ZipList 的最大内存大小（单位：KB）。
- **`list-compress-depth`**：控制 QuickList 的压缩深度。
  - 0：不压缩。
  - 1：压缩两端节点。
  - 2：压缩两端和中间节点。

#### 示例配置：
```ini
list-max-ziplist-size -2  # 每个 ZipList 最大占用 8KB
list-compress-depth 1     # 压缩两端节点
```


### 5. **总结**
- **ZipList**：适合存储小规模的列表或哈希表，内存紧凑但性能有限。
- **QuickList**：结合了 ZipList 和双向链表的优点，适合存储大规模的列表，内存高效且性能较好。
