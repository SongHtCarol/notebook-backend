# 数据库

> reference:<br>
> https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93<br>
> [《数据库系统原理及应用教程》](http://s.cmpedu.com/booksource/upload/pdf/YZ_08594T.pdf)<br>
> [《分布式数据库系统及其应用》](https://www.ecsponline.com/yz/B0A3CE3D9612740D5B6F861FFE67E4C21000.pdf)
- [数据库](#数据库)
  - [什么是数据库？以及数据库管理系统](#什么是数据库以及数据库管理系统)
  - [锁](#锁)
    - [1. **锁的粒度**](#1-锁的粒度)
    - [2. **并发性能**](#2-并发性能)
    - [3. **锁的类型**](#3-锁的类型)
    - [4. **适用场景**](#4-适用场景)
    - [5. **实现复杂度**](#5-实现复杂度)
    - [6. **死锁问题**](#6-死锁问题)
    - [7. **示例对比**](#7-示例对比)
      - [表级锁（MyISAM）](#表级锁myisam)
      - [行级锁（InnoDB）](#行级锁innodb)
    - [8. **性能对比**](#8-性能对比)
    - [9. **总结**](#9-总结)
  - [读锁](#读锁)
    - [**一、读锁的核心特性**](#一读锁的核心特性)
    - [**二、读锁的应用场景**](#二读锁的应用场景)
      - [1. **数据库事务**](#1-数据库事务)
      - [2. **多线程编程**](#2-多线程编程)
      - [3. **文件系统操作**](#3-文件系统操作)
    - [**三、读锁的工作原理**](#三读锁的工作原理)
      - [1. **锁的状态管理**](#1-锁的状态管理)
      - [2. **锁的获取与释放**](#2-锁的获取与释放)
      - [3. **公平性与优先级**](#3-公平性与优先级)
    - [**四、读锁的优缺点**](#四读锁的优缺点)
    - [**五、读锁与写锁的对比**](#五读锁与写锁的对比)
    - [**六、最佳实践与注意事项**](#六最佳实践与注意事项)
    - [**七、常见问题与解决方案**](#七常见问题与解决方案)
      - [**问题 1：写锁饥饿**](#问题-1写锁饥饿)
      - [**问题 2：锁开销过大**](#问题-2锁开销过大)
    - [**八、总结**](#八总结)

---

## 什么是数据库？以及数据库管理系统
**数据库**`是以一定方式储存在一起、能予多个用户共享、具有尽可能小的冗余度、与应用程序彼此独立的数据集合。一个数据库由多个表空间（Tablespace）构成。`

**数据库管理系统（Database Management System）**：`为管理数据库而设计的电脑软件系统，一般具有存储、截取、安全保障、备份等基础功能`

<img src='/database/img/mindnote.png'>

---
## 锁
_表级锁和行级锁对比_
表级锁和行级锁是数据库中两种常见的锁机制，用于控制并发访问数据时的资源争用。它们在锁的粒度、并发性能和应用场景上有显著区别。以下是表级锁和行级锁的详细对比：


### 1. **锁的粒度**
- **表级锁**：
  - 锁定整个表。
  - 当一个会话对表加锁时，其他会话无法对该表进行写操作（读操作可能允许，取决于锁类型）。
- **行级锁**：
  - 锁定表中的某一行或几行。
  - 当一个会话对某行加锁时，其他会话仍然可以访问表中的其他行。


### 2. **并发性能**
- **表级锁**：
  - **优点**：实现简单，开销小。
  - **缺点**：并发性能差，多个会话无法同时修改同一表的不同行。
- **行级锁**：
  - **优点**：并发性能高，多个会话可以同时修改同一表的不同行。
  - **缺点**：实现复杂，开销较大。


### 3. **锁的类型**
- **表级锁**：
  - **读锁（共享锁）**：允许其他会话读取表，但不允许写入。
  - **写锁（排他锁）**：不允许其他会话读取或写入表。
- **行级锁**：
  - **共享锁（S锁）**：允许其他会话读取同一行，但不允许写入。
  - **排他锁（X锁）**：不允许其他会话读取或写入同一行。


### 4. **适用场景**
- **表级锁**：
  - 适合读多写少的场景。
  - 适合数据量较小的表。
  - 适合不需要高并发的应用。
- **行级锁**：
  - 适合写多读少的场景。
  - 适合数据量较大的表。
  - 适合需要高并发的应用。


### 5. **实现复杂度**
- **表级锁**：
  - 实现简单，数据库只需管理表的锁状态。
- **行级锁**：
  - 实现复杂，数据库需要管理每行的锁状态，开销较大。


### 6. **死锁问题**
- **表级锁**：
  - 死锁概率低，因为锁的粒度大，会话之间的竞争较少。
- **行级锁**：
  - 死锁概率较高，因为多个会话可能同时竞争同一表的不同行。


### 7. **示例对比**
#### 表级锁（MyISAM）
```sql
-- 会话1
LOCK TABLE my_table WRITE; -- 加写锁
INSERT INTO my_table VALUES (1, 'Alice');
-- 其他会话无法读取或写入 my_table
UNLOCK TABLES; -- 释放锁

-- 会话2
SELECT * FROM my_table; -- 等待会话1释放锁
```

#### 行级锁（InnoDB）
```sql
-- 会话1
START TRANSACTION;
SELECT * FROM my_table WHERE id = 1 FOR UPDATE; -- 对 id=1 的行加排他锁
UPDATE my_table SET name = 'Bob' WHERE id = 1;
COMMIT; -- 释放锁

-- 会话2
START TRANSACTION;
SELECT * FROM my_table WHERE id = 2 FOR UPDATE; -- 可以访问其他行
UPDATE my_table SET name = 'Charlie' WHERE id = 2;
COMMIT;
```


### 8. **性能对比**
| 特性            | 表级锁       | 行级锁       |
|-----------------|--------------|--------------|
| **锁粒度**      | 粗粒度       | 细粒度       |
| **并发性能**    | 低           | 高           |
| **实现复杂度**  | 简单         | 复杂         |
| **死锁概率**    | 低           | 高           |
| **适用场景**    | 读多写少     | 写多读少     |


### 9. **总结**
- **表级锁**：适合读多写少、数据量小的场景，实现简单但并发性能差。
- **行级锁**：适合写多读少、数据量大的场景，实现复杂但并发性能高。

---
## 读锁
在并发编程和数据库管理系统中，**读锁（Read Lock）** 是一种用于控制多线程或多事务环境下数据访问的同步机制，旨在保障数据的一致性和安全性。以下是读锁的核心概念、应用场景及实现原理的详细解析：


### **一、读锁的核心特性**
1. **共享性（Shared Lock）**  
   读锁是共享锁，允许多个线程或事务同时获取同一资源的读锁，实现并发读取。
2. **互斥性**  
   读锁与写锁（独占锁）互斥：  
   - **读锁 vs 读锁**：允许共存。  
   - **读锁 vs 写锁**：互斥阻塞（写锁需等待所有读锁释放）。
3. **非阻塞性**  
   多个读操作可并行执行，提升系统吞吐量。

### **二、读锁的应用场景**
#### 1. **数据库事务**
   - **场景**：事务 A 读取数据时加读锁，事务 B 可同时读取，但事务 C 的写操作需等待。
   - **示例**（SQL）：
     ```sql
     -- 显式加读锁（部分数据库支持）
     SELECT * FROM table WHERE id = 1 LOCK IN SHARE MODE;
     ```

#### 2. **多线程编程**
   - **场景**：多个线程读取共享数据，避免脏读。
   - **示例**（Java）：
     ```java
     ReentrantReadWriteLock lock = new ReentrantReadWriteLock();
     lock.readLock().lock();  // 获取读锁
     try {
         // 读取共享数据
     } finally {
         lock.readLock().unlock();
     }
     ```

#### 3. **文件系统操作**
   - **场景**：多个进程读取同一文件，禁止写入操作干扰。
   - **示例**（Linux 文件锁）：
     ```c
     flock(fd, LOCK_SH);  // 加共享锁（读锁）
     ```


### **三、读锁的工作原理**
#### 1. **锁的状态管理**
   - **计数器机制**：记录当前持有读锁的线程数。  
     - 计数器 > 0：允许其他读锁，拒绝写锁。  
     - 计数器 = 0：允许写锁获取。

#### 2. **锁的获取与释放**
   - **获取读锁**：  
     检查当前无写锁，增加读锁计数器。  
   - **释放读锁**：  
     减少计数器，若计数器归零则唤醒等待的写锁。

#### 3. **公平性与优先级**
   - **非公平锁**（默认）：允许插队，可能写锁饥饿。  
   - **公平锁**：按请求顺序分配锁，避免饥饿但性能较低。


### **四、读锁的优缺点**
| **优点**                      | **缺点**                          |
|-------------------------------|-----------------------------------|
| 提升并发读取性能              | 写操作可能被长时间阻塞（读多写少场景） |
| 避免脏读（读取稳定快照）      | 锁竞争可能增加系统开销            |
| 实现简单，逻辑清晰            | 不当使用可能导致死锁              |


### **五、读锁与写锁的对比**
| **特性**       | **读锁（共享锁）**                | **写锁（独占锁）**                |
|----------------|-----------------------------------|-----------------------------------|
| **并发性**     | 允许多个线程同时持有              | 仅允许一个线程持有                |
| **互斥性**     | 与写锁互斥                        | 与所有锁（读/写）互斥             |
| **适用场景**   | 高频读取，低频写入（如缓存）      | 数据修改、写入操作                |
| **性能影响**   | 减少锁竞争，提升吞吐量            | 增加锁竞争，降低并发性            |


### **六、最佳实践与注意事项**
1. **锁粒度控制**  
   - 尽量减小锁的作用范围（如锁定单个数据项而非整个表）。
2. **避免锁升级**  
   - 读锁升级为写锁需谨慎（可能引发死锁）。
3. **超时机制**  
   - 为锁操作设置超时，防止长时间阻塞。
   ```java
   if (lock.readLock().tryLock(1, TimeUnit.SECONDS)) {
       try { /* ... */ } finally { lock.readLock().unlock(); }
   }
   ```
4. **死锁预防**  
   - 按固定顺序获取锁，避免循环等待。


### **七、常见问题与解决方案**
#### **问题 1：写锁饥饿**
- **现象**：读锁持续占用，写锁长时间无法获取。  
- **解决**：  
  - 使用公平锁（按请求顺序分配）。  
  - 限制读锁的最大持有时间。

#### **问题 2：锁开销过大**
- **现象**：高并发下锁竞争导致性能下降。  
- **解决**：  
  - 使用无锁数据结构（如 CAS 操作）。  
  - 采用读写分离架构（如 CQRS 模式）。

### **八、总结**
读锁通过共享访问机制，在保障数据一致性的同时最大化读取并发度，是处理读多写少场景的核心工具。合理使用读锁需平衡性能与安全性，结合业务特点选择锁策略（如公平性、超时机制），并辅以监控工具（如数据库死锁日志、JVM 线程分析）优化系统表现。