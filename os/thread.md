# 线程

- [线程](#线程)


---
## 线程和协程
**协程（Coroutine）** 和 **线程（Thread）** 是两种并发编程的实现方式，它们在资源占用、调度方式和适用场景上有显著区别。以下是它们的详细对比：


### 一、定义
#### 1. **线程**
- 线程是操作系统调度的最小单位，是进程中的一个执行流。
- 线程由操作系统内核管理，支持抢占式调度（Preemptive Scheduling）。

#### 2. **协程**
- 协程是一种用户态的轻量级线程，由程序控制调度。
- 协程的调度是非抢占式的（Cooperative Scheduling），需要显式让出执行权。


### 二、核心区别
| **特性**               | **线程**                              | **协程**                              |
|------------------------|----------------------------------------|---------------------------------------|
| **调度方式**           | 操作系统内核调度（抢占式）             | 用户程序调度（非抢占式）              |
| **上下文切换开销**     | 高（涉及内核态和用户态切换）           | 低（仅在用户态切换）                  |
| **并发能力**           | 受限于线程数量（资源占用高）           | 支持大量并发（资源占用低）            |
| **编程复杂度**         | 较高（需处理锁、竞态条件等）           | 较低（通常无需锁）                    |
| **适用场景**           | CPU 密集型任务、需要并行计算的场景      | I/O 密集型任务、高并发网络编程        |
| **资源占用**           | 每个线程占用独立栈空间（通常 MB 级）   | 每个协程占用栈空间小（通常 KB 级）    |
| **实现语言支持**       | 大多数编程语言原生支持                 | 需要语言或库支持（如 Python、Go）     |


### 三、详细对比
#### 1. **调度方式**
- **线程**：
  - 由操作系统内核调度，采用抢占式调度。
  - 线程的执行可能被操作系统随时中断，切换到其他线程。
- **协程**：
  - 由用户程序调度，采用非抢占式调度。
  - 协程需要显式让出执行权（如通过 `yield` 或 `await`），才能切换到其他协程。

#### 2. **上下文切换开销**
- **线程**：
  - 上下文切换涉及内核态和用户态的切换，开销较大。
  - 每次切换需要保存和恢复寄存器、栈指针等状态。
- **协程**：
  - 上下文切换仅在用户态完成，开销极小。
  - 只需保存和恢复少量寄存器状态。

#### 3. **并发能力**
- **线程**：
  - 受限于线程数量，创建过多线程会导致资源耗尽（如内存、CPU）。
  - 通常建议的线程数量为 CPU 核心数的 2-4 倍。
- **协程**：
  - 支持大量并发，一个程序可以轻松创建数万个协程。
  - 协程的栈空间小，资源占用低。

#### 4. **编程复杂度**
- **线程**：
  - 需要处理锁、竞态条件、死锁等多线程编程问题。
  - 调试和排查问题较为复杂。
- **协程**：
  - 通常无需锁，因为协程是单线程执行的。
  - 代码逻辑更接近同步编程，易于理解和调试。

#### 5. **适用场景**
- **线程**：
  - 适合 CPU 密集型任务（如计算、图像处理）。
  - 需要并行计算的场景。
- **协程**：
  - 适合 I/O 密集型任务（如网络请求、文件读写）。
  - 高并发网络编程（如 Web 服务器、爬虫）。

#### 6. **资源占用**
- **线程**：
  - 每个线程需要分配独立的栈空间（通常为 MB 级）。
  - 创建大量线程会导致内存耗尽。
- **协程**：
  - 每个协程的栈空间小（通常为 KB 级）。
  - 可以轻松创建大量协程。


### 四、示例对比
#### 1. **线程示例（Python）**
```python
import threading

def worker():
    print("Thread started")
    # 模拟 I/O 操作
    import time
    time.sleep(1)
    print("Thread finished")

# 创建 10 个线程
threads = []
for i in range(10):
    t = threading.Thread(target=worker)
    threads.append(t)
    t.start()

# 等待所有线程完成
for t in threads:
    t.join()
```

#### 2. **协程示例（Python）**
```python
import asyncio

async def worker():
    print("Coroutine started")
    # 模拟 I/O 操作
    await asyncio.sleep(1)
    print("Coroutine finished")

async def main():
    # 创建 10 个协程
    tasks = [asyncio.create_task(worker()) for _ in range(10)]
    await asyncio.gather(*tasks)

# 运行协程
asyncio.run(main())
```


### 五、总结
- **线程**：
  - 适合 CPU 密集型任务和需要并行计算的场景。
  - 资源占用高，编程复杂度高。
- **协程**：
  - 适合 I/O 密集型任务和高并发网络编程。
  - 资源占用低，编程复杂度低。

选择线程还是协程取决于具体需求：
- 如果需要并行计算或与操作系统紧密交互，选择 **线程**。
- 如果需要高并发 I/O 操作或简化并发编程，选择 **协程**。

---

## 子函数和协程的区别
**子函数（Subroutine）** 和 **协程（Coroutine）** 是两种不同的程序执行单元，它们在执行方式、控制流和适用场景上有显著区别。以下是它们的详细对比：


### 一、定义
#### 1. **子函数**
- 子函数是程序中的一个独立代码块，通过函数调用执行。
- 子函数执行完毕后，控制权返回给调用者，子函数的状态不会保留。

#### 2. **协程**
- 协程是一种特殊的函数，可以在执行过程中暂停（Yield）并恢复（Resume）。
- 协程的状态在暂停时会保留，恢复时从暂停点继续执行。


### 二、核心区别
| **特性**               | **子函数**                          | **协程**                              |
|------------------------|--------------------------------------|---------------------------------------|
| **执行方式**           | 一次性执行，完成后返回               | 可暂停和恢复，保留状态                |
| **控制流**             | 线性执行                             | 非抢占式，显式让出控制权              |
| **状态保存**           | 不保存状态                           | 保存局部变量和执行状态                |
| **调用关系**           | 调用者等待子函数完成                 | 调用者和协程可以交替执行              |
| **适用场景**           | 普通函数调用                         | 异步编程、并发任务                    |
| **资源占用**           | 栈空间较小                           | 栈空间较小，但需保存状态              |
| **实现语言支持**       | 所有编程语言支持                     | 需要语言或库支持（如 Python、Go）     |


### 三、详细对比
#### 1. **执行方式**
- **子函数**：
  - 子函数被调用后，从头到尾执行，完成后返回调用者。
  - 每次调用子函数时，其局部变量和执行状态都会重新初始化。
- **协程**：
  - 协程可以在执行过程中暂停（通过 `yield` 或 `await`），并在稍后恢复执行。
  - 协程的状态（如局部变量、程序计数器）在暂停时会保留。

#### 2. **控制流**
- **子函数**：
  - 控制流是线性的，调用者等待子函数执行完毕。
  - 子函数无法主动让出控制权。
- **协程**：
  - 控制流是非抢占式的，协程可以显式让出控制权。
  - 调用者和协程可以交替执行，实现协作式多任务。

#### 3. **状态保存**
- **子函数**：
  - 子函数的局部变量和执行状态在每次调用时重新初始化。
  - 不保存状态，适合无状态的逻辑。
- **协程**：
  - 协程的局部变量和执行状态在暂停时会保存。
  - 恢复时从暂停点继续执行，适合有状态的逻辑。

#### 4. **调用关系**
- **子函数**：
  - 调用者调用子函数后，必须等待子函数执行完毕。
  - 子函数无法主动返回控制权给调用者。
- **协程**：
  - 调用者和协程可以交替执行，协程可以主动让出控制权。
  - 适合实现异步编程和并发任务。

#### 5. **适用场景**
- **子函数**：
  - 适合普通函数调用，如数学计算、数据处理。
  - 适合无状态的逻辑。
- **协程**：
  - 适合异步编程，如网络请求、文件读写。
  - 适合有状态的逻辑，如状态机、生成器。

#### 6. **资源占用**
- **子函数**：
  - 每次调用子函数时，栈空间较小，适合频繁调用。
- **协程**：
  - 协程需要保存状态，栈空间稍大，但支持大量并发。


### 四、示例对比
#### 1. **子函数示例（Python）**
```python
def subroutine():
    print("Subroutine started")
    # 模拟 I/O 操作
    import time
    time.sleep(1)
    print("Subroutine finished")

# 调用子函数
subroutine()
```

#### 2. **协程示例（Python）**
```python
import asyncio

async def coroutine():
    print("Coroutine started")
    # 模拟 I/O 操作
    await asyncio.sleep(1)
    print("Coroutine finished")

# 运行协程
asyncio.run(coroutine())
```


### 五、总结
- **子函数**：
  - 适合普通函数调用，执行完毕后返回调用者。
  - 不保存状态，适合无状态的逻辑。
- **协程**：
  - 适合异步编程和并发任务，可以暂停和恢复。
  - 保存状态，适合有状态的逻辑。

选择子函数还是协程取决于具体需求：
- 如果需要简单的函数调用，选择 **子函数**。
- 如果需要异步编程或并发任务，选择 **协程**。
