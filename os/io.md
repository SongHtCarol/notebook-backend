# I/O

- [I/O](#io)



---
## epoll
`epoll` 是 Linux 内核提供的一种高效 I/O 事件通知机制，用于处理大量文件描述符（File Descriptors, FD）的 I/O 事件。它是 `select` 和 `poll` 的改进版本，特别适合高并发场景。以下是 `epoll` 的详细介绍：


### 一、`epoll` 的核心特点
1. **高效的事件通知机制**  
   - `epoll` 使用红黑树和双向链表管理文件描述符，事件检测的时间复杂度为 \(O(1)\)。
   - 相比 `select` 和 `poll` 的 \(O(n)\) 时间复杂度，`epoll` 在处理大量文件描述符时性能显著提升。

2. **支持边缘触发（ET）和水平触发（LT）模式**  
   - **水平触发（LT）**：只要文件描述符处于就绪状态，`epoll` 就会持续通知应用程序。
   - **边缘触发（ET）**：只有当文件描述符状态发生变化时，`epoll` 才会通知应用程序。

3. **无文件描述符数量限制**  
   - `select` 和 `poll` 的文件描述符数量受 `FD_SETSIZE` 限制（通常为 1024），而 `epoll` 支持的文件描述符数量仅受系统内存限制。

4. **内核与用户空间共享内存**  
   - `epoll` 使用内存映射（mmap）技术，减少了内核与用户空间之间的数据拷贝。


### 二、`epoll` 的核心 API
`epoll` 提供了三个主要的系统调用：
1. **`epoll_create`**  
   创建一个 `epoll` 实例，返回一个文件描述符。
   ```c
   int epoll_create(int size);  // size 参数已弃用，传入大于 0 的值即可
   ```

2. **`epoll_ctl`**  
   向 `epoll` 实例中添加、修改或删除需要监控的文件描述符。
   ```c
   int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
   ```
   - `epfd`：`epoll` 实例的文件描述符。
   - `op`：操作类型（`EPOLL_CTL_ADD`、`EPOLL_CTL_MOD`、`EPOLL_CTL_DEL`）。
   - `fd`：需要监控的文件描述符。
   - `event`：事件类型（如 `EPOLLIN`、`EPOLLOUT` 等）。

3. **`epoll_wait`**  
   等待文件描述符上的 I/O 事件。
   ```c
   int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);
   ```
   - `epfd`：`epoll` 实例的文件描述符。
   - `events`：用于存储就绪事件的数组。
   - `maxevents`：最多返回的事件数量。
   - `timeout`：超时时间（毫秒）。


### 三、`epoll` 的工作模式
1. **水平触发（LT）**  
   - 默认模式。
   - 只要文件描述符处于就绪状态，`epoll_wait` 就会持续通知应用程序。
   - 示例：如果 socket 缓冲区中有数据未读完，`epoll_wait` 会一直通知。

2. **边缘触发（ET）**  
   - 需要显式设置（`EPOLLET` 标志）。
   - 只有当文件描述符状态发生变化时，`epoll_wait` 才会通知应用程序。
   - 示例：如果 socket 缓冲区中有新数据到达，`epoll_wait` 才会通知。


### 四、`epoll` 的使用示例
以下是一个简单的 `epoll` 服务器示例：
```c
#include <sys/epoll.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_EVENTS 10

int main() {
    int server_fd, client_fd, epoll_fd;
    struct sockaddr_in addr;
    struct epoll_event ev, events[MAX_EVENTS];

    // 创建 socket
    server_fd = socket(AF_INET, SOCK_STREAM, 0);
    addr.sin_family = AF_INET;
    addr.sin_addr.s_addr = INADDR_ANY;
    addr.sin_port = htons(8080);

    // 绑定 socket
    bind(server_fd, (struct sockaddr *)&addr, sizeof(addr));
    listen(server_fd, 5);

    // 创建 epoll 实例
    epoll_fd = epoll_create1(0);
    ev.events = EPOLLIN;
    ev.data.fd = server_fd;
    epoll_ctl(epoll_fd, EPOLL_CTL_ADD, server_fd, &ev);

    while (1) {
        int nfds = epoll_wait(epoll_fd, events, MAX_EVENTS, -1);
        for (int i = 0; i < nfds; i++) {
            if (events[i].data.fd == server_fd) {
                // 接受新连接
                client_fd = accept(server_fd, NULL, NULL);
                ev.events = EPOLLIN | EPOLLET;  // 设置为边缘触发
                ev.data.fd = client_fd;
                epoll_ctl(epoll_fd, EPOLL_CTL_ADD, client_fd, &ev);
            } else {
                // 处理客户端数据
                char buffer[1024];
                int len = read(events[i].data.fd, buffer, sizeof(buffer));
                if (len > 0) {
                    write(events[i].data.fd, buffer, len);
                } else {
                    close(events[i].data.fd);
                }
            }
        }
    }

    close(epoll_fd);
    close(server_fd);
    return 0;
}
```


### 五、`epoll` 的适用场景
1. **高并发服务器**  
   如 Web 服务器、即时通讯服务器等，需要处理大量并发连接。

2. **实时性要求高的应用**  
   如游戏服务器、实时数据采集系统等。

3. **文件描述符数量较多的场景**  
   如文件传输、数据库连接池等。


### 六、`epoll` 的优缺点
#### 优点：
- 高效的事件检测机制（时间复杂度 \(O(1)\)）。
- 支持边缘触发模式，减少事件通知次数。
- 无文件描述符数量限制。

#### 缺点：
- 仅适用于 Linux 系统。
- 边缘触发模式需要应用程序正确处理未读完的数据。


### 七、总结
- `epoll` 是 Linux 下高效处理大量文件描述符的 I/O 事件通知机制。
- 支持水平触发和边缘触发模式，适合高并发场景。
- 通过 `epoll_create`、`epoll_ctl` 和 `epoll_wait` 三个 API 实现事件管理。
- 在高性能服务器开发中，`epoll` 是首选的事件驱动模型。

## epoll 红黑树和双向链表
在 Linux 的 `epoll` 机制中，**红黑树（Red-Black Tree）** 和 **双向链表（Doubly Linked List）** 是两个核心数据结构，共同协作以实现高效的事件管理。以下是它们的角色和工作原理的详细解析：


### 一、红黑树的作用
#### 1. **管理所有被监控的文件描述符（FD）**
- 当调用 `epoll_ctl`（添加、修改或删除 FD）时，`epoll` 使用红黑树来存储所有需要监控的 FD 和对应的事件（`epitem` 结构）。
- **键（Key）**：FD 的值（`int fd`）。
- **值（Value）**：FD 的监控事件（如 `EPOLLIN`、`EPOLLOUT`）和其他元数据。

#### 2. **红黑树的优势**
- **高效查找**：红黑树是一种自平衡二叉搜索树，查找、插入、删除的时间复杂度均为 \(O(\log n)\)，适合动态管理大量 FD。
- **动态调整**：当频繁添加或删除 FD 时，红黑树能保持平衡，避免性能退化。

#### 3. **示例场景**
- 当调用 `epoll_ctl(epfd, EPOLL_CTL_ADD, fd, &event)` 添加一个 FD 时，内核会将该 FD 插入红黑树。
- 当调用 `epoll_ctl(epfd, EPOLL_CTL_DEL, fd, NULL)` 删除一个 FD 时，内核会从红黑树中移除该 FD。


### 二、双向链表的作用
#### 1. **管理就绪事件**
- 当某个 FD 发生 I/O 事件（如可读、可写）时，内核会将该 FD 对应的 `epitem` 结构添加到 **就绪队列（Ready List）**（一个双向链表）。
- 当用户调用 `epoll_wait` 时，内核只需遍历这个双向链表，将就绪事件返回给用户空间。

#### 2. **双向链表的优势**
- **高效插入和删除**：双向链表的插入和删除操作时间复杂度为 \(O(1)\)，适合频繁更新就绪事件。
- **顺序遍历**：用户调用 `epoll_wait` 时，内核可以快速遍历链表，将就绪事件批量返回。

#### 3. **示例场景**
- 当某个 socket 接收到数据时，内核检测到 `EPOLLIN` 事件，将该 FD 插入就绪队列。
- `epoll_wait` 会从就绪队列中取出这些 FD，并返回给用户程序。


### 三、红黑树和双向链表的协作流程
1. **初始化**：
   - 用户调用 `epoll_create` 创建一个 `epoll` 实例，内核初始化红黑树和就绪队列（双向链表）。

2. **添加监控的 FD**：
   - 用户调用 `epoll_ctl(EPOLL_CTL_ADD)`，将 FD 插入红黑树。

3. **事件触发**：
   - 当 FD 发生 I/O 事件（如可读），内核将其对应的 `epitem` 从红黑树中找到，并添加到就绪队列。

4. **获取就绪事件**：
   - 用户调用 `epoll_wait`，内核遍历就绪队列，将事件返回给用户，并清空队列（ET 模式）或保留未处理的事件（LT 模式）。

5. **删除 FD**：
   - 用户调用 `epoll_ctl(EPOLL_CTL_DEL)`，内核从红黑树和就绪队列中移除该 FD。


### 四、两种数据结构的性能优势
| **操作**               | **红黑树**               | **双向链表**             |
|------------------------|--------------------------|--------------------------|
| **查找 FD**            | \(O(\log n)\)            | 不直接支持               |
| **插入/删除 FD**       | \(O(\log n)\)            | 不直接支持               |
| **管理就绪事件**       | 不参与                   | \(O(1)\) 插入/删除       |
| **遍历就绪事件**       | 不参与                   | \(O(1)\) 顺序访问        |

- **红黑树**：负责高效管理所有被监控的 FD，支持快速查找和动态调整。
- **双向链表**：负责快速记录和分发就绪事件，减少遍历开销。


### 五、水平触发（LT）和边缘触发（ET）的影响
- **水平触发（LT）**：
  - 如果 FD 的事件未处理完（如 socket 缓冲区仍有数据），该 FD 会重新被加入就绪队列。
  - 双向链表可能会多次包含同一个 FD。

- **边缘触发（ET）**：
  - 只有当 FD 状态变化时（如新数据到达），才会被加入就绪队列。
  - 用户必须一次性处理完所有数据，否则可能丢失事件。


### 六、总结
- **红黑树**：用于高效管理所有被监控的 FD，支持动态增删查改。
- **双向链表**：用于快速记录和分发就绪事件，提升 `epoll_wait` 的效率。
- **协作机制**：红黑树保证 FD 的管理效率，双向链表保证事件通知的实时性。

`epoll` 通过红黑树和双向链表的结合，实现了高性能的事件驱动模型，尤其适合高并发场景（如 Web 服务器、实时通信系统）。

## epoll为什么用双向链表，而不用单向链表
在 Linux 的 `epoll` 机制中，**双向链表（Doubly Linked List）** 被用于管理就绪事件队列（Ready List），而不是单向链表（Singly Linked List）。选择双向链表的原因主要与其在事件管理中的高效性和灵活性有关。以下是详细分析：


### 一、双向链表的优势
#### 1. **支持双向遍历**
- **需求**：在 `epoll` 中，就绪事件队列需要支持从头部插入新事件，并从头部或尾部移除事件。
- **双向链表的优势**：
  - 可以从头部或尾部快速插入和删除节点。
  - 支持双向遍历，方便从任意方向操作链表。

#### 2. **高效删除任意节点**
- **需求**：在 `epoll` 中，可能需要从就绪队列中删除某个特定事件（例如，某个文件描述符的事件已处理完毕）。
- **双向链表的优势**：
  - 已知节点位置时，删除操作的时间复杂度为 \(O(1)\)。
  - 单向链表需要从头遍历才能找到前驱节点，删除操作的时间复杂度为 \(O(n)\)。

#### 3. **支持事件的重插入**
- **需求**：在水平触发（LT）模式下，如果事件未处理完（如 socket 缓冲区仍有数据），需要将事件重新插入就绪队列。
- **双向链表的优势**：
  - 可以快速将节点从链表中移除并重新插入到头部或尾部。

#### 4. **灵活性更高**
- **需求**：`epoll` 需要支持多种操作（如插入、删除、遍历、重插入等）。
- **双向链表的优势**：
  - 提供更多的操作灵活性，适合复杂的事件管理场景。


### 二、单向链表的局限性
#### 1. **删除操作效率低**
- 单向链表在删除节点时，需要从头遍历找到前驱节点，时间复杂度为 \(O(n)\)。
- 在 `epoll` 中，频繁删除节点会导致性能下降。

#### 2. **不支持双向遍历**
- 单向链表只能从头到尾遍历，无法从尾到头遍历。
- 在 `epoll` 中，可能需要从尾部移除事件（例如，清理过期事件），单向链表无法高效支持。

#### 3. **灵活性不足**
- 单向链表的操作受限，无法高效支持复杂的事件管理需求。


### 三、`epoll` 中双向链表的具体应用
在 `epoll` 中，双向链表用于管理 **就绪事件队列（Ready List）**，其工作流程如下：
1. **事件触发**：
   - 当某个文件描述符（FD）发生 I/O 事件（如可读、可写），内核将其对应的 `epitem` 结构添加到就绪队列的头部。
2. **事件处理**：
   - 用户调用 `epoll_wait` 时，内核遍历就绪队列，将事件返回给用户。
3. **事件移除**：
   - 在边缘触发（ET）模式下，事件处理完毕后，内核从就绪队列中移除该事件。
   - 在水平触发（LT）模式下，如果事件未处理完（如 socket 缓冲区仍有数据），内核会将该事件重新插入就绪队列。

双向链表的特性完美支持上述流程：
- **快速插入**：新事件插入到链表头部，时间复杂度为 \(O(1)\)。
- **快速删除**：已知节点位置时，删除操作的时间复杂度为 \(O(1)\)。
- **支持重插入**：未处理完的事件可以快速重新插入链表。


### 四、性能对比
| **操作**         | **双向链表**       | **单向链表**       |
|------------------|--------------------|--------------------|
| **插入（头部）** | \(O(1)\)           | \(O(1)\)           |
| **删除（已知节点）** | \(O(1)\)       | \(O(n)\)           |
| **遍历**         | 双向遍历            | 单向遍历            |
| **重插入**       | \(O(1)\)           | \(O(n)\)           |


### 五、总结
- **双向链表** 在 `epoll` 中被用于管理就绪事件队列，主要因为其支持高效插入、删除和双向遍历。
- **单向链表** 由于删除操作效率低、不支持双向遍历，无法满足 `epoll` 的高效事件管理需求。
- **双向链表的灵活性** 使其成为 `epoll` 实现中的理想选择，能够高效处理高并发场景下的 I/O 事件。

通过使用双向链表，`epoll` 能够在高并发场景下实现高效的事件通知和管理，成为 Linux 高性能网络编程的核心机制之一。

## 双向链表性能
**双向链表（Doubly Linked List）** 是一种常见的数据结构，其性能特点在特定场景下非常突出。以下是双向链表的性能分析及其适用场景：


### 一、双向链表的结构
双向链表的每个节点包含三个部分：
1. **数据域**：存储实际数据。
2. **前驱指针（prev）**：指向前一个节点。
3. **后继指针（next）**：指向后一个节点。

示例结构：
```c
struct Node {
    int data;          // 数据域
    struct Node *prev; // 前驱指针
    struct Node *next; // 后继指针
};
```

### 二、双向链表的性能特点
#### 1. **插入和删除操作**
- **时间复杂度**：\(O(1)\)（已知节点位置时）。
- **优势**：
  - 在链表头部、尾部或任意已知节点位置插入/删除节点非常高效。
  - 无需移动其他节点，只需调整指针。

#### 2. **查找操作**
- **时间复杂度**：\(O(n)\)。
- **劣势**：
  - 需要从头或尾遍历链表，直到找到目标节点。
  - 不适合频繁查找的场景。

#### 3. **遍历操作**
- **时间复杂度**：\(O(n)\)。
- **优势**：
  - 支持双向遍历（从头到尾或从尾到头）。
  - 适合需要频繁遍历的场景。

#### 4. **空间开销**
- **额外空间**：每个节点需要存储前驱和后继指针，空间开销较大（相比单向链表）。


### 三、双向链表的适用场景
1. **频繁插入和删除**
   - 示例：实现双向队列（Deque）、LRU 缓存淘汰算法。
   - 原因：插入和删除操作的时间复杂度为 \(O(1)\)。

2. **需要双向遍历**
   - 示例：浏览器的前进/后退功能、文本编辑器的撤销/重做功能。
   - 原因：双向链表支持从任意方向遍历。

3. **动态内存分配**
   - 示例：内存池管理、操作系统的进程调度队列。
   - 原因：链表可以动态扩展和收缩，无需预先分配固定大小的内存。

4. **实现复杂数据结构**
   - 示例：跳表（Skip List）、图的邻接表表示。
   - 原因：双向链表可以灵活地与其他数据结构结合。


### 四、双向链表的性能对比
| **操作**         | **双向链表**       | **单向链表**       | **数组**           |
|------------------|--------------------|--------------------|--------------------|
| **插入/删除**    | \(O(1)\)           | \(O(1)\)           | \(O(n)\)           |
| **查找**         | \(O(n)\)           | \(O(n)\)           | \(O(1)\)（索引访问）|
| **遍历**         | \(O(n)\)（双向）   | \(O(n)\)（单向）   | \(O(n)\)           |
| **空间开销**     | 较高（两个指针）   | 较低（一个指针）   | 无额外指针         |


### 五、双向链表的优缺点
#### 优点：
1. **插入和删除高效**：在已知节点位置时，时间复杂度为 \(O(1)\)。
2. **支持双向遍历**：可以从头到尾或从尾到头遍历链表。
3. **动态扩展**：无需预先分配固定大小的内存。

#### 缺点：
1. **查找效率低**：需要遍历链表，时间复杂度为 \(O(n)\)。
2. **空间开销大**：每个节点需要存储两个指针。
3. **实现复杂**：相比单向链表，代码实现更复杂。


### 六、双向链表的应用示例
#### 1. **实现 LRU 缓存**
- **需求**：最近最少使用（LRU）缓存需要快速插入、删除和查找。
- **实现**：
  - 使用双向链表存储缓存项，最近使用的项放在链表头部。
  - 使用哈希表快速定位链表中的节点。

#### 2. **实现双向队列（Deque）**
- **需求**：支持在头部和尾部高效插入和删除。
- **实现**：
  - 使用双向链表实现，头部和尾部操作的时间复杂度均为 \(O(1)\)。

#### 3. **实现文本编辑器的撤销/重做功能**
- **需求**：支持用户操作的撤销和重做。
- **实现**：
  - 使用双向链表存储操作历史，支持双向遍历。


### 七、总结
- **双向链表** 在插入、删除和双向遍历方面性能优异，适合动态内存管理和需要频繁修改的场景。
- **查找性能较差**，不适合需要频繁查找的场景。
- **空间开销较大**，每个节点需要存储两个指针。

在实际开发中，双向链表常用于实现高级数据结构（如 LRU 缓存、双向队列）或需要双向遍历的场景。