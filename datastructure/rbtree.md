# 红黑树

- [红黑树](#红黑树)
  - [红黑树介绍](#红黑树介绍)
    - [概念](#概念)
    - [树高](#树高)
    - [插入](#插入)
    - [删除](#删除)
  - [红黑树的STL实现](#红黑树的stl实现)
    - [数据结构定义](#数据结构定义)
    - [遍历](#遍历)
  - [底层使用了红黑树的STL结构](#底层使用了红黑树的stl结构)
    - [map/mutimap](#mapmutimap)
    - [set/multiset](#setmultiset)
  - [应用](#应用)
    - [linux内核](#linux内核)
    - [开源框架](#开源框架)

---

## 红黑树介绍
### 概念
红黑树是满足以下性质的二叉搜索树：
- 每个节点是红色或者黑色
- 根节点是黑色的
- 每个叶子节点是黑色的
- 如果一个节点为红色，则其孩子节点必为黑色
- 从任一节点到其后代叶子的路径上，均包含相同数目的黑色节点

```
黑高：从某节点x（不包含该节点），到叶子的任一条路径上的黑色节点个数，称为该节点的黑高。
任何一个节点，左右子树高度差不超过两倍
```

<img src='/datastructure/img/rbtree.jpg'>

### 树高
假设红黑树的高度为h，根到叶子节点至少有一半是黑色节点，根的黑高至少为h/2，那么高位h/2的完全二叉树节点数为2^(h/2)-1。除了这些节点，剩下的h/2肯定还有节点存在。
因此：
```
n >= 2^(h/2)-1
```
即
```
n + 1 >= 2^(h/2)
log(n+1) >= h/2
h <= 2log(n+1) = log(n+1)
```

因此红黑树的查找、插入、删除的时间复杂度为`log(n+1)`

### 插入
- 根节点是黑色的
- 红节点的孩子节点必为黑色
- 左右子树黑高相同

1. 在红黑树中插入x，先查找，如果查找成功则直接返回，如果查找失败，继续
2. 在查找失败的位置创建x节点，并置为红色。如果是树根则置为黑色
3. 如果新插入节点x的父亲为黑色，则仍然满足红黑树的条件，插入成功
4. 如果新插入节点x的父亲为红色，则出现双红，此时需要修正，使其满足红黑树的条件

### 删除
1. 在红黑树中删除x，先查找，如果查找失败则直接返回，如果查找成功，继续
2. 如果x节点仅有左子树（或右子树），则删除x及诶点，令其左子树（或右子树）子承父业代替其位置
3. 如果x节点有左子树和右子树，则令x的直接前驱（或直接后继）代替其位置，然后删除其直接前驱（或直接后继）即可
4. 在删除过程中可能违反红黑树性质，需要修正

## 红黑树的STL实现
### 数据结构定义
<img src='/datastructure/img/stl_rbtree.jpg'>

### 遍历
<img src='/datastructure/img/rbtree ++.png'>

## 底层使用了红黑树的STL结构
### map/mutimap
<img src='/datastructure/img/stl_map.jpg'>
<img src='/datastructure/img/stl_map compare.jpg'>

### set/multiset
<img src='/datastructure/img/stl_set.jpg'>
<img src='/datastructure/img/stl_set compare.jpg'>

## 应用
### linux内核
- 进程调度
- 内存管理
- epoll
### 开源框架
- nginx
- 共享内存
- 定时器模块