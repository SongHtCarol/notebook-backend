# B-Tree/B+Tree

- [B-Tree/B+Tree](#b-treebtree)
  - [B-Tree](#b-tree)
    - [概念](#概念)
    - [特点](#特点)
    - [树高](#树高)
    - [查找](#查找)
    - [插入](#插入)
    - [删除](#删除)
  - [B+Tree](#btree)
    - [概念](#概念-1)
    - [查找](#查找-1)
    - [插入](#插入-1)
    - [删除](#删除-1)

---
## B-Tree
### 概念
B树，多路平衡搜索树。一棵m阶B树，或为空树，或满足以下特性：
- 每个节点最多有m棵子树
- 根节点至少有两棵子树
- 内部节点（除根和叶子之外的节点）至少有⌈m/2⌉棵子树
- 终端节点（叶子）在同一层上，并且不带信息（空指针），通常称为失败节点
- 非终端节点的关键字个数比子树个数少1

<img src='/datastructure/img/Btree.jpg'>

### 特点
- 平衡： 所有叶子节点都在同一层，左右子树高度差为0
- 有序：中序有序，左子树 < 根 < 右子树
- 多路：m阶B树中的节点最多可以有m个分支

### 树高
1. 根节点至少有两棵子树 => 第二层至少两个节点
2. 内部节点（除根和叶子之外的节点）至少有⌈m/2⌉棵子树
   1. => 第三层至少2*⌈m/2⌉个节点 
   2. => 第h+1层至少2*⌈m/2⌉^(h-1)个节点 
<img src='/datastructure/img/m-Btree.jpg'>

叶子节点至少有2*⌈m/2⌉^(h-1)个， 叶子节点为查找失败的空指针。假设整棵树有n个关键字，则有n+1种查找失败的情况，即有n+1个叶子节点。
`n+1 >= 2*⌈m/2⌉^(h-1)`
`h <= log⌈m/2⌉((n+1)/2) + 1`

一棵有n个关键字的m阶B树，最大高度为`O(logm(n))`.

### 查找
1. 在根节点的关键字中查找，查找成功返回。查找失败继续
2. 判断是否为叶子节点，是的话结束，查找失败。不是，则从外存载入节点到内存，反复1的过程

时间复杂度
节点间的跳转作为一次外存访问
节点内的查找作为多次内存访问 => 对比外存访问，可以忽略不计

一次查找 => 访问了多少个节点 => 最多从根访问到叶子节点，即树高。
含有n个关键字的m阶B树，查找的时间复杂度为`O(logm(n))`.

### 插入
关键字不允许重复
每个节点最多有m棵子树 => 每个节点至多有m-1个关键字

1. 在B树中查找合适的位置
   1. 查找成功直接返回，不插入
   2. 查找失败，将关键字插入到失败节点的双亲节点中
2. 插入关键字后
   1. 节点中关键字个数小于m，则成功
   2. 节点中关键字个数大于等于m，需分裂。
   3. 分裂操作： 取上溢节点中间的关键字，上升到其父节点。如果父节点也上溢，则按此操作一直上升，直到根节点。
    <img src='/datastructure/img/split.jpg'>

含有n个关键字的m阶B树，插入操作除了查找插入位置之外`O(logm(n))`，如果发生上溢需要分裂操作。分裂操作不会超过树的高度`O(logm(n))`。
插入的时间复杂度为`O(logm(n))`.

### 删除
根节点至少有两棵子树 => 根节点至少有一个关键字
内部节点（除根和叶子之外的节点）至少有⌈m/2⌉棵子树 => 内部节点至少有⌈m/2⌉-1个关键字

1. 在B树中查找待删除关键字
   1. 查找失败，则不做操作返回
   2. 查找成功，删除。
      1. 如果待删除的关键字的子树非空，则需要像二叉搜索树一样，另该关键字的直接前驱或者直接后继代替删除关键字。然后删除直接前驱或者直接后继。
      2. 直接前驱或者直接后继的子树一定为空
      3. 待删除关键字的子树为空
2. 删除关键字后
   1. 关键字个数大于等于⌈m/2⌉-1，则成功
   2. 关键字个数小于⌈m/2⌉-1，发生下溢。根据下溢节点的左右兄弟情况
      1. 下溢节点左兄弟的关键字大于等于⌈m/2⌉，左借
            <img src='/datastructure/img/borrow left.jpg'>
      2. 下溢节点右兄弟的关键字大于等于⌈m/2⌉，右借
            <img src='/datastructure/img/borrow right.jpg'>
      3. 下溢节点的左右兄弟的关键字都不足⌈m/2⌉，合并
             <img src='/datastructure/img/merge.jpg'>

含有n个关键字的m阶B树，删除操作除了查找删除位置之外`O(logm(n))`，如果发生下溢需要左借/右借/合并操作。左借/右借/合并操作不会超过树的高度`O(logm(n))`。
删除的时间复杂度为`O(logm(n))`.

## B+Tree

### 概念
一棵m阶B+树，或为空树，或满足以下特性：
- 每个节点最多有m棵子树
- 根节点至少有两棵子树
- 内部节点（除根和叶子之外的节点）至少有⌈m/2⌉棵子树
- 终端节点（叶子）在同一层上，并且不带信息（空指针），通常称为失败节点
- **非终端节点的关键字个数与子树个数相同**
- **倒数第二层节点包含了全部的关键字，节点内部有序且节点间按升序顺序链接。**
- **所有的非终端节点只作为索引部分，节点中仅含子树中的最大（或最小）关键字**
<img src='/datastructure/img/b+tree.jpg'>

### 查找
B+树支持两种查找方式，可以利用root指针从树根向下索引查找，也可以利用left指针从最小关键字向后顺序查找。
- 从树根向下索引查找，时间复杂度为`O(logm(n))`.
- 顺序查找，时间复杂度为`O(n)`.

B+树不仅支持单个关键字查找，还支持范围查找。

### 插入
- 仅在最后一层非终端节点插入
- 如果插入后节点个数超过m，发生上溢，需要分裂操作
- 分裂时，上升到父节点的关键字，在子节点中仍然保留
<img src='/datastructure/img/b+ split.jpg'>
<img src='/datastructure/img/b+ root split.jpg'>

时间复杂度为`O(logm(n))`

### 删除
- 仅在最后一层非终端节点进行删除
- 判断删除后是否发生下溢
- 判断是否需要更新父节点的关键字

<img src='/datastructure/img/b+ delete.jpg'>
<img src='/datastructure/img/b+ delete merge.jpg'>

时间复杂度为`O(logm(n))`