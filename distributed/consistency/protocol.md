# 分布式协议

- [分布式协议](#分布式协议)
    - [原子提交协议和分布式事务解决方案](#原子提交协议和分布式事务解决方案)
      - [2PC协议](#2pc协议)
      - [3PC协议](#3pc协议)
      - [Best Efforts 1 PC事务](#best-efforts-1-pc事务)
      - [TCC事务](#tcc事务)
      - [SAGA事务](#saga事务)
    - [并发控制协议](#并发控制协议)
      - [悲观并发控制协议](#悲观并发控制协议)
        - [锁](#锁)
        - [解决死锁问题](#解决死锁问题)
        - [时间戳排序协议](#时间戳排序协议)
      - [乐观并发控制协议](#乐观并发控制协议)
        - [三个阶段](#三个阶段)
      - [多版本并发控制协议](#多版本并发控制协议)
        - [优势](#优势)
        - [协议拆解](#协议拆解)
        - [数据版本存储](#数据版本存储)
        - [垃圾回收](#垃圾回收)

---

### 原子提交协议和分布式事务解决方案
#### 2PC协议
协调者 + 多个参与者： 参与者执行操作，协调者控制过程。
第一阶段，所有参与者执行操作并反馈
第二阶段，所有参与者提交
问题：
- 协调者节点单点问题：协调者崩溃的情况下，通过备用协调者查询各个参与者的状态决定事务是否该继续执行（callback函数）
- 阻塞问题：第一阶段执行后，事务涉及到的资源一直都是锁定状态知道参与者节点收到协调者节点第二阶段的命令。（用clientid锁定一个过程）
- 协调者节点和任意参与者节点在第二阶段崩溃：协调者崩溃，备用协调者无法询问到所有参与者，就要一直等到节点恢复

#### 3PC协议
将2PC协议的第一阶段拆分成请求准备阶段和准备提交阶段。协调者在请求准备阶段询问所有参与者节点是否可以执行事务操作，全部返回ok则开始第二阶段执行操作。
相比于2PC，降低了事务失败回滚的概率，但是增加了数据不一致的风险，以及增加了事务延迟

#### Best Efforts 1 PC事务
最大努力一阶段提交，也称为可靠事件队列。主要利用消息中间件的可靠性机制来实现数据一致性。有最终一致性。
反复重试直到成功。
- 有最大重试次数或者超时时间
- 重试的时间间隔：等距或者衰减
- 达到最大重试次数： 人工查询确认或者定时对账
业务处理实现过程中要遵循幂等设计，或者通过事务补偿机制实现最终一致性

#### TCC事务
Try - Confirm/Cancel，两阶段补偿事务
- Try：尝试阶段 业务检查，资源预留
- Confirm：确认阶段 执行业务操作
- Cancel：撤销阶段 如果Try阶段出现错误，就cancel掉try阶段的所有操作

#### SAGA事务
改善长事务，长事务可以认为是多个可以交错运行的短事务的集合。如果SAGA中的任意一个子事务无法正常运行，那么一定要执行补偿操作。
补偿方案包括前向恢复和后向恢复。前向恢复，一致重试直到成功，不做补偿。后向恢复，撤销掉之前成功的所有子事务。
- 子事务和补偿事务应该具有幂等性
- 分布式事务正常提交的结果应该是和其子事务全部成功提交的结果保持一致

TCC事务的定位是对一致性要求较高的短事务，SAGA则是一致性要求较低的长事务/短事务，比如订机票，可能持续几分钟甚至一两天

### 并发控制协议
#### 悲观并发控制协议
##### 锁
如果某些操作可能和其他操作发生冲突，那么直接放弃执行该操作，待到完全不可能发生冲突的时候再执行该操作。
- 2PL（两阶段锁）：加锁阶段和解锁阶段。加锁阶段只能一直获得锁，不能解锁。解锁阶段只能一直解锁不能再获得锁。有联级回滚问题。
- S2PL（严格两阶段锁）：可以解决联级回滚问题。事务一致持有已经获得的写锁，直到事务终止。
- SS2PL（强严格两阶段锁）：不仅一直保留写锁，还会同时保留读锁到事务结束。

##### 解决死锁问题
死锁检测：检测到环，回滚相关事务解开环
死锁预防：根据时间戳为每个事务赋予优先级，一般时间戳越小的事务优先级越高。高优先级礼让低优先级/低优先级礼让高优先级

##### 时间戳排序协议
按照时间戳值的顺序拥有事务
成功执行读/写的任务事务的最大时间戳
- 时间戳排序协议确保了可串行化隔离级别
- 时间戳协议确保没有死锁，没有事务等待
- 调度可能不是无级联的，甚至可能不是可恢复的

#### 乐观并发控制协议
- 没有死锁，避免了任何耗时的节点锁定场景
- 如果事务以查询为主，那么乐观并发控制开销几乎可以忽略不计
- 读取操作完全不受限制，而事务的写入操作则受到严格限制

##### 三个阶段
- 读阶段：事务维护读集和写集。所有读取操作先访问事务本地内存空间，如果没有再访问数据库。所有写操作的缓存都保留在只面向本地事务的私有空间，不向其他事务暴露。
- 验证阶段：事务调度器将对上面的操作验证，检测其是否满足某种可串行化标准
- 写阶段：将事务私有空间中的缓存写入数据库使其全局可见。

适用于事务冲突发生次数较少的情况，避免了使用锁的开销，可以带来更好的性能。当事务冲突次数较多时，会导致事务的频繁回滚，反而降低效率。

#### 多版本并发控制协议
##### 优势
- 写操作不会阻塞读操作，读操作也不会阻塞写操作
- 不需要锁
- 支持时间回溯查询

##### 协议拆解
- 并发控制协议，可以是悲观并发控制协议，也可以是乐观并发控制协议
- 数据版本存储
- 垃圾回收，将长期不用的数据版本丢弃

##### 数据版本存储
- Append-Only Storage：所有版本的数据都存储在同一张表
- Time-Travel Storage：将最新的版本数据和历史数据分开存储，最新的数据版本会有指针链接值历史数据版本的表
- Delta Storage：每次进行版本更新的时候，只会将产生变化的字段信息存储到Delta Table中，不会存储没有变化的字段

##### 垃圾回收
- 根据时间戳清除
- 根据事务读写集合清除：当数据库决定该事务创建的个版本数据可以被清除的时候，就根据读写集合内的数据版本清除